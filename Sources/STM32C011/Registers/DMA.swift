// Generated by svd2swift.

import MMIO

/// DMA controller
@RegisterBlock
public struct DMA: Sendable {
    /// DMA interrupt status register
    @RegisterBlock(offset: 0x0)
    public var isr: Register<ISR>

    /// DMA interrupt flag clear register
    @RegisterBlock(offset: 0x4)
    public var ifcr: Register<IFCR>

    /// DMA channel 1 configuration register
    @RegisterBlock(offset: 0x8)
    public var ccr1: Register<CCR1>

    /// DMA channel 1 number of data to transfer register
    @RegisterBlock(offset: 0xc)
    public var cndtr1: Register<CNDTR1>

    /// DMA channel 1 peripheral address register
    @RegisterBlock(offset: 0x10)
    public var cpar1: Register<CPAR1>

    /// DMA channel 1 memory address register
    @RegisterBlock(offset: 0x14)
    public var cmar1: Register<CMAR1>

    /// DMA channel 2 configuration register
    @RegisterBlock(offset: 0x1c)
    public var ccr2: Register<CCR2>

    /// DMA channel 2 number of data to transfer register
    @RegisterBlock(offset: 0x20)
    public var cndtr2: Register<CNDTR2>

    /// DMA channel 2 peripheral address register
    @RegisterBlock(offset: 0x24)
    public var cpar2: Register<CPAR2>

    /// DMA channel 2 memory address register
    @RegisterBlock(offset: 0x28)
    public var cmar2: Register<CMAR2>

    /// DMA channel 3 configuration register
    @RegisterBlock(offset: 0x30)
    public var ccr3: Register<CCR3>

    /// DMA channel 3 number of data to transfer register
    @RegisterBlock(offset: 0x34)
    public var cndtr3: Register<CNDTR3>

    /// DMA channel 3 peripheral address register
    @RegisterBlock(offset: 0x38)
    public var cpar3: Register<CPAR3>

    /// DMA channel 3 memory address register
    @RegisterBlock(offset: 0x3c)
    public var cmar3: Register<CMAR3>
}

extension DMA {
    /// DMA interrupt status register
    @Register(bitWidth: 32)
    public struct ISR {
        /// global interrupt flag for channel 1
        @ReadOnly(bits: 0..<1)
        public var gif1: GIF1

        /// transfer complete (TC) flag for channel 1
        @ReadOnly(bits: 1..<2)
        public var tcif1: TCIF1

        /// half transfer (HT) flag for channel 1
        @ReadOnly(bits: 2..<3)
        public var htif1: HTIF1

        /// transfer error (TE) flag for channel 1
        @ReadOnly(bits: 3..<4)
        public var teif1: TEIF1

        /// global interrupt flag for channel 2
        @ReadOnly(bits: 4..<5)
        public var gif2: GIF2

        /// transfer complete (TC) flag for channel 2
        @ReadOnly(bits: 5..<6)
        public var tcif2: TCIF2

        /// half transfer (HT) flag for channel 2
        @ReadOnly(bits: 6..<7)
        public var htif2: HTIF2

        /// transfer error (TE) flag for channel 2
        @ReadOnly(bits: 7..<8)
        public var teif2: TEIF2

        /// global interrupt flag for channel 3
        @ReadOnly(bits: 8..<9)
        public var gif3: GIF3

        /// transfer complete (TC) flag for channel 3
        @ReadOnly(bits: 9..<10)
        public var tcif3: TCIF3

        /// half transfer (HT) flag for channel 3
        @ReadOnly(bits: 10..<11)
        public var htif3: HTIF3

        /// transfer error (TE) flag for channel 3
        @ReadOnly(bits: 11..<12)
        public var teif3: TEIF3
    }

    /// DMA interrupt flag clear register
    @Register(bitWidth: 32)
    public struct IFCR {
        /// global interrupt flag clear for channel 1
        @WriteOnly(bits: 0..<1)
        public var cgif1: CGIF1

        /// transfer complete flag clear for channel 1
        @WriteOnly(bits: 1..<2)
        public var ctcif1: CTCIF1

        /// half transfer flag clear for channel 1
        @WriteOnly(bits: 2..<3)
        public var chtif1: CHTIF1

        /// transfer error flag clear for channel 1
        @WriteOnly(bits: 3..<4)
        public var cteif1: CTEIF1

        /// global interrupt flag clear for channel 2
        @WriteOnly(bits: 4..<5)
        public var cgif2: CGIF2

        /// transfer complete flag clear for channel 2
        @WriteOnly(bits: 5..<6)
        public var ctcif2: CTCIF2

        /// half transfer flag clear for channel 2
        @WriteOnly(bits: 6..<7)
        public var chtif2: CHTIF2

        /// transfer error flag clear for channel 2
        @WriteOnly(bits: 7..<8)
        public var cteif2: CTEIF2

        /// global interrupt flag clear for channel 3
        @WriteOnly(bits: 8..<9)
        public var cgif3: CGIF3

        /// transfer complete flag clear for channel 3
        @WriteOnly(bits: 9..<10)
        public var ctcif3: CTCIF3

        /// half transfer flag clear for channel 3
        @WriteOnly(bits: 10..<11)
        public var chtif3: CHTIF3

        /// transfer error flag clear for channel 3
        @WriteOnly(bits: 11..<12)
        public var cteif3: CTEIF3
    }

    /// DMA channel 1 configuration register
    @Register(bitWidth: 32)
    public struct CCR1 {
        /// channel enable
        /// When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).
        /// Note: this bit is set and cleared by software.
        @ReadWrite(bits: 0..<1)
        public var en: EN

        /// transfer complete interrupt enable
        /// Note: this bit is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is not read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 1..<2)
        public var tcie: TCIE

        /// half transfer interrupt enable
        /// Note: this bit is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is not read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 2..<3)
        public var htie: HTIE

        /// transfer error interrupt enable
        /// Note: this bit is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is not read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 3..<4)
        public var teie: TEIE

        /// data transfer direction
        /// This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
        /// Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.
        /// Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.
        /// Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.
        /// Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.
        /// Note: this bit is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 4..<5)
        public var dir: DIR

        /// circular mode
        /// Note: this bit is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is not read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 5..<6)
        public var circ: CIRC

        /// peripheral increment mode
        /// Defines the increment mode for each DMA transfer to the identified peripheral.
        /// n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
        /// In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
        /// Note: this bit is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 6..<7)
        public var pinc: PINC

        /// memory increment mode
        /// Defines the increment mode for each DMA transfer to the identified memory.
        /// In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
        /// In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
        /// Note: this bit is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 7..<8)
        public var minc: MINC

        /// peripheral size
        /// Defines the data size of each DMA transfer to the identified peripheral.
        /// In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
        /// In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
        /// Note: this field is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 8..<10)
        public var psize: PSIZE

        /// memory size
        /// Defines the data size of each DMA transfer to the identified memory.
        /// In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
        /// In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
        /// Note: this field is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 10..<12)
        public var msize: MSIZE

        /// priority level
        /// Note: this field is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 12..<14)
        public var pl: PL

        /// memory-to-memory mode
        /// Note: this bit is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 14..<15)
        public var mem2mem: MEM2MEM
    }

    /// DMA channel 1 number of data to transfer register
    @Register(bitWidth: 32)
    public struct CNDTR1 {
        /// number of data to transfer (0 to 216 - 1)
        /// This field is updated by hardware when the channel is enabled:
        /// It is decremented after each single DMA ‘read followed by write’ transfer, indicating the remaining amount of data items to transfer.
        /// It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the DMA_CCRx register).
        /// It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
        /// If this field is zero, no transfer can be served whatever the channel status (enabled or not).
        /// Note: this field is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 0..<16)
        public var ndt: NDT
    }

    /// DMA channel 1 peripheral address register
    @Register(bitWidth: 32)
    public struct CPAR1 {
        /// peripheral address
        /// It contains the base address of the peripheral data register from/to which the data will be read/written.
        /// When PSIZE[1:0] = 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.
        /// When PSIZE = 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address.
        /// In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
        /// In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
        /// Note: this register is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is not read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 0..<32)
        public var pa: PA
    }

    /// DMA channel 1 memory address register
    @Register(bitWidth: 32)
    public struct CMAR1 {
        /// peripheral address
        /// It contains the base address of the memory from/to which the data will be read/written.
        /// When MSIZE[1:0] = 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.
        /// When MSIZE = 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address.
        /// In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
        /// In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
        /// Note: this register is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is not read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 0..<32)
        public var ma: MA
    }

    /// DMA channel 2 configuration register
    @Register(bitWidth: 32)
    public struct CCR2 {
        /// channel enable
        /// When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).
        /// Note: this bit is set and cleared by software.
        @ReadWrite(bits: 0..<1)
        public var en: EN

        /// transfer complete interrupt enable
        /// Note: this bit is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is not read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 1..<2)
        public var tcie: TCIE

        /// half transfer interrupt enable
        /// Note: this bit is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is not read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 2..<3)
        public var htie: HTIE

        /// transfer error interrupt enable
        /// Note: this bit is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is not read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 3..<4)
        public var teie: TEIE

        /// data transfer direction
        /// This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
        /// Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.
        /// Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.
        /// Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.
        /// Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.
        /// Note: this bit is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 4..<5)
        public var dir: DIR

        /// circular mode
        /// Note: this bit is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is not read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 5..<6)
        public var circ: CIRC

        /// peripheral increment mode
        /// Defines the increment mode for each DMA transfer to the identified peripheral.
        /// n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
        /// In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
        /// Note: this bit is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 6..<7)
        public var pinc: PINC

        /// memory increment mode
        /// Defines the increment mode for each DMA transfer to the identified memory.
        /// In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
        /// In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
        /// Note: this bit is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 7..<8)
        public var minc: MINC

        /// peripheral size
        /// Defines the data size of each DMA transfer to the identified peripheral.
        /// In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
        /// In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
        /// Note: this field is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 8..<10)
        public var psize: PSIZE

        /// memory size
        /// Defines the data size of each DMA transfer to the identified memory.
        /// In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
        /// In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
        /// Note: this field is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 10..<12)
        public var msize: MSIZE

        /// priority level
        /// Note: this field is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 12..<14)
        public var pl: PL

        /// memory-to-memory mode
        /// Note: this bit is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 14..<15)
        public var mem2mem: MEM2MEM
    }

    /// DMA channel 2 number of data to transfer register
    @Register(bitWidth: 32)
    public struct CNDTR2 {
        /// number of data to transfer (0 to 216 - 1)
        /// This field is updated by hardware when the channel is enabled:
        /// It is decremented after each single DMA ‘read followed by write’ transfer, indicating the remaining amount of data items to transfer.
        /// It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the DMA_CCRx register).
        /// It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
        /// If this field is zero, no transfer can be served whatever the channel status (enabled or not).
        /// Note: this field is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 0..<16)
        public var ndt: NDT
    }

    /// DMA channel 2 peripheral address register
    @Register(bitWidth: 32)
    public struct CPAR2 {
        /// peripheral address
        /// It contains the base address of the peripheral data register from/to which the data will be read/written.
        /// When PSIZE[1:0] = 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.
        /// When PSIZE = 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address.
        /// In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
        /// In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
        /// Note: this register is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is not read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 0..<32)
        public var pa: PA
    }

    /// DMA channel 2 memory address register
    @Register(bitWidth: 32)
    public struct CMAR2 {
        /// peripheral address
        /// It contains the base address of the memory from/to which the data will be read/written.
        /// When MSIZE[1:0] = 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.
        /// When MSIZE = 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address.
        /// In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
        /// In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
        /// Note: this register is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is not read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 0..<32)
        public var ma: MA
    }

    /// DMA channel 3 configuration register
    @Register(bitWidth: 32)
    public struct CCR3 {
        /// channel enable
        /// When a channel transfer error occurs, this bit is cleared by hardware. It can not be set again by software (channel x re-activated) until the TEIFx bit of the DMA_ISR register is cleared (by setting the CTEIFx bit of the DMA_IFCR register).
        /// Note: this bit is set and cleared by software.
        @ReadWrite(bits: 0..<1)
        public var en: EN

        /// transfer complete interrupt enable
        /// Note: this bit is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is not read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 1..<2)
        public var tcie: TCIE

        /// half transfer interrupt enable
        /// Note: this bit is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is not read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 2..<3)
        public var htie: HTIE

        /// transfer error interrupt enable
        /// Note: this bit is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is not read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 3..<4)
        public var teie: TEIE

        /// data transfer direction
        /// This bit must be set only in memory-to-peripheral and peripheral-to-memory modes.
        /// Source attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.
        /// Destination attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.
        /// Destination attributes are defined by PSIZE and PINC, plus the DMA_CPARx register. This is still valid in a memory-to-memory mode.
        /// Source attributes are defined by MSIZE and MINC, plus the DMA_CMARx register. This is still valid in a peripheral-to-peripheral mode.
        /// Note: this bit is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 4..<5)
        public var dir: DIR

        /// circular mode
        /// Note: this bit is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is not read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 5..<6)
        public var circ: CIRC

        /// peripheral increment mode
        /// Defines the increment mode for each DMA transfer to the identified peripheral.
        /// n memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
        /// In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
        /// Note: this bit is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 6..<7)
        public var pinc: PINC

        /// memory increment mode
        /// Defines the increment mode for each DMA transfer to the identified memory.
        /// In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
        /// In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
        /// Note: this bit is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 7..<8)
        public var minc: MINC

        /// peripheral size
        /// Defines the data size of each DMA transfer to the identified peripheral.
        /// In memory-to-memory mode, this field identifies the memory destination if DIR = 1 and the memory source if DIR = 0.
        /// In peripheral-to-peripheral mode, this field identifies the peripheral destination if DIR = 1 and the peripheral source if DIR = 0.
        /// Note: this field is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 8..<10)
        public var psize: PSIZE

        /// memory size
        /// Defines the data size of each DMA transfer to the identified memory.
        /// In memory-to-memory mode, this field identifies the memory source if DIR = 1 and the memory destination if DIR = 0.
        /// In peripheral-to-peripheral mode, this field identifies the peripheral source if DIR = 1 and the peripheral destination if DIR = 0.
        /// Note: this field is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 10..<12)
        public var msize: MSIZE

        /// priority level
        /// Note: this field is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 12..<14)
        public var pl: PL

        /// memory-to-memory mode
        /// Note: this bit is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 14..<15)
        public var mem2mem: MEM2MEM
    }

    /// DMA channel 3 number of data to transfer register
    @Register(bitWidth: 32)
    public struct CNDTR3 {
        /// number of data to transfer (0 to 216 - 1)
        /// This field is updated by hardware when the channel is enabled:
        /// It is decremented after each single DMA ‘read followed by write’ transfer, indicating the remaining amount of data items to transfer.
        /// It is kept at zero when the programmed amount of data to transfer is reached, if the channel is not in circular mode (CIRC = 0 in the DMA_CCRx register).
        /// It is reloaded automatically by the previously programmed value, when the transfer is complete, if the channel is in circular mode (CIRC = 1).
        /// If this field is zero, no transfer can be served whatever the channel status (enabled or not).
        /// Note: this field is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 0..<16)
        public var ndt: NDT
    }

    /// DMA channel 3 peripheral address register
    @Register(bitWidth: 32)
    public struct CPAR3 {
        /// peripheral address
        /// It contains the base address of the peripheral data register from/to which the data will be read/written.
        /// When PSIZE[1:0] = 01 (16 bits), bit 0 of PA[31:0] is ignored. Access is automatically aligned to a half-word address.
        /// When PSIZE = 10 (32 bits), bits 1 and 0 of PA[31:0] are ignored. Access is automatically aligned to a word address.
        /// In memory-to-memory mode, this register identifies the memory destination address if DIR = 1 and the memory source address if DIR = 0.
        /// In peripheral-to-peripheral mode, this register identifies the peripheral destination address DIR = 1 and the peripheral source address if DIR = 0.
        /// Note: this register is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is not read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 0..<32)
        public var pa: PA
    }

    /// DMA channel 3 memory address register
    @Register(bitWidth: 32)
    public struct CMAR3 {
        /// peripheral address
        /// It contains the base address of the memory from/to which the data will be read/written.
        /// When MSIZE[1:0] = 01 (16 bits), bit 0 of MA[31:0] is ignored. Access is automatically aligned to a half-word address.
        /// When MSIZE = 10 (32 bits), bits 1 and 0 of MA[31:0] are ignored. Access is automatically aligned to a word address.
        /// In memory-to-memory mode, this register identifies the memory source address if DIR = 1 and the memory destination address if DIR = 0.
        /// In peripheral-to-peripheral mode, this register identifies the peripheral source address DIR = 1 and the peripheral destination address if DIR = 0.
        /// Note: this register is set and cleared by software.
        /// It must not be written when the channel is enabled (EN = 1).
        /// It is not read-only when the channel is enabled (EN = 1).
        @ReadWrite(bits: 0..<32)
        public var ma: MA
    }
}

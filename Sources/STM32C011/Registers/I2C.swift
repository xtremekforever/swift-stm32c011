// Generated by svd2swift.

import MMIO

/// I2C register block
@RegisterBlock
public struct I2C: Sendable {
    /// I2C control register 1
    @RegisterBlock(offset: 0x0)
    public var cr1: Register<CR1>

    /// I2C control register 2
    @RegisterBlock(offset: 0x4)
    public var cr2: Register<CR2>

    /// I2C own address 1 register
    @RegisterBlock(offset: 0x8)
    public var oar1: Register<OAR1>

    /// I2C own address 2 register
    @RegisterBlock(offset: 0xc)
    public var oar2: Register<OAR2>

    /// I2C timing register
    @RegisterBlock(offset: 0x10)
    public var timingr: Register<TIMINGR>

    /// I2C timeout register
    @RegisterBlock(offset: 0x14)
    public var timeoutr: Register<TIMEOUTR>

    /// I2C interrupt and status register
    @RegisterBlock(offset: 0x18)
    public var isr: Register<ISR>

    /// I2C interrupt clear register
    @RegisterBlock(offset: 0x1c)
    public var icr: Register<ICR>

    /// I2C PEC register
    @RegisterBlock(offset: 0x20)
    public var pecr: Register<PECR>

    /// I2C receive data register
    @RegisterBlock(offset: 0x24)
    public var rxdr: Register<RXDR>

    /// I2C transmit data register
    @RegisterBlock(offset: 0x28)
    public var txdr: Register<TXDR>
}

extension I2C {
    /// I2C control register 1
    @Register(bitWidth: 32)
    public struct CR1 {
        /// Note: When PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles.
        @ReadWrite(bits: 0..<1)
        public var pe: PE

        /// TX Interrupt enable
        @ReadWrite(bits: 1..<2)
        public var txie: TXIE

        /// RX Interrupt enable
        @ReadWrite(bits: 2..<3)
        public var rxie: RXIE

        /// Address match Interrupt enable (slave only)
        @ReadWrite(bits: 3..<4)
        public var addrie: ADDRIE

        /// Not acknowledge received Interrupt enable
        @ReadWrite(bits: 4..<5)
        public var nackie: NACKIE

        /// Stop detection Interrupt enable
        @ReadWrite(bits: 5..<6)
        public var stopie: STOPIE

        /// Transfer Complete Reload (TCR)
        @ReadWrite(bits: 6..<7)
        public var tcie: TCIE

        /// Alert pin event detection (ALERT)
        @ReadWrite(bits: 7..<8)
        public var errie: ERRIE

        /// This filter can only be programmed when the I2C is disabled (PE = 0).
        @ReadWrite(bits: 8..<12)
        public var dnf: DNF

        /// Note: This bit can only be programmed when the I2C is disabled (PE = 0).
        @ReadWrite(bits: 12..<13)
        public var anfoff: ANFOFF

        /// DMA transmission requests enable
        @ReadWrite(bits: 14..<15)
        public var txdmaen: TXDMAEN

        /// DMA reception requests enable
        @ReadWrite(bits: 15..<16)
        public var rxdmaen: RXDMAEN

        /// This bit is used to enable hardware byte control in slave mode.
        @ReadWrite(bits: 16..<17)
        public var sbc: SBC

        /// Note: This bit can only be programmed when the I2C is disabled (PE = 0).
        @ReadWrite(bits: 17..<18)
        public var nostretch: NOSTRETCH

        /// Note: WUPEN can be set only when DNF = ‘0000’
        @ReadWrite(bits: 18..<19)
        public var wupen: WUPEN

        /// General call enable
        @ReadWrite(bits: 19..<20)
        public var gcen: GCEN

        /// Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .
        @ReadWrite(bits: 20..<21)
        public var smbhen: SMBHEN

        /// Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .
        @ReadWrite(bits: 21..<22)
        public var smbden: SMBDEN

        /// If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .
        @ReadWrite(bits: 22..<23)
        public var alerten: ALERTEN

        /// Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .
        @ReadWrite(bits: 23..<24)
        public var pecen: PECEN
    }

    /// I2C control register 2
    @Register(bitWidth: 32)
    public struct CR2 {
        /// Note: Changing these bits when the START bit is set is not allowed.
        @ReadWrite(bits: 0..<10)
        public var sadd: SADD

        /// Note: Changing this bit when the START bit is set is not allowed.
        @ReadWrite(bits: 10..<11)
        public var rd_wrn: RD_WRN

        /// Note: Changing this bit when the START bit is set is not allowed.
        @ReadWrite(bits: 11..<12)
        public var add10: ADD10

        /// Note: Changing this bit when the START bit is set is not allowed.
        @ReadWrite(bits: 12..<13)
        public var head10r: HEAD10R

        /// This bit has no effect when RELOAD is set.
        @ReadWrite(bits: 13..<14)
        public var start: START

        /// Note: Writing ‘0’ to this bit has no effect.
        @ReadWrite(bits: 14..<15)
        public var stop: STOP

        /// When hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value.
        @ReadWrite(bits: 15..<16)
        public var nack: NACK

        /// Note: Changing these bits when the START bit is set is not allowed.
        @ReadWrite(bits: 16..<24)
        public var nbytes: NBYTES

        /// This bit is set and cleared by software.
        @ReadWrite(bits: 24..<25)
        public var reload: RELOAD

        /// Note: This bit has no effect in slave mode or when the RELOAD bit is set.
        @ReadWrite(bits: 25..<26)
        public var autoend: AUTOEND

        /// If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .
        @ReadWrite(bits: 26..<27)
        public var pecbyte: PECBYTE
    }

    /// I2C own address 1 register
    @Register(bitWidth: 32)
    public struct OAR1 {
        /// Note: These bits can be written only when OA1EN=0.
        @ReadWrite(bits: 0..<10)
        public var oa1: OA1

        /// Note: This bit can be written only when OA1EN=0.
        @ReadWrite(bits: 10..<11)
        public var oa1mode: OA1MODE

        /// Own Address 1 enable
        @ReadWrite(bits: 15..<16)
        public var oa1en: OA1EN
    }

    /// I2C own address 2 register
    @Register(bitWidth: 32)
    public struct OAR2 {
        /// Note: These bits can be written only when OA2EN=0.
        @ReadWrite(bits: 1..<8)
        public var oa2: OA2

        /// As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches.
        @ReadWrite(bits: 8..<11)
        public var oa2msk: OA2MSK

        /// Own Address 2 enable
        @ReadWrite(bits: 15..<16)
        public var oa2en: OA2EN
    }

    /// I2C timing register
    @Register(bitWidth: 32)
    public struct TIMINGR {
        /// Note: SCLL is also used to generate tBUF and tSU:STA timings.
        @ReadWrite(bits: 0..<8)
        public var scll: SCLL

        /// Note: SCLH is also used to generate tSU:STO and tHD:STA timing.
        @ReadWrite(bits: 8..<16)
        public var sclh: SCLH

        /// Note: SDADEL is used to generate tHD:DAT timing.
        @ReadWrite(bits: 16..<20)
        public var sdadel: SDADEL

        /// Note: tSCLDEL is used to generate tSU:DAT timing.
        @ReadWrite(bits: 20..<24)
        public var scldel: SCLDEL

        /// tPRESC = (PRESC+1) x tI2CCLK
        @ReadWrite(bits: 28..<32)
        public var presc: PRESC
    }

    /// I2C timeout register
    @Register(bitWidth: 32)
    public struct TIMEOUTR {
        /// Note: These bits can be written only when TIMOUTEN=0.
        @ReadWrite(bits: 0..<12)
        public var timeouta: TIMEOUTA

        /// Note: This bit can be written only when TIMOUTEN=0.
        @ReadWrite(bits: 12..<13)
        public var tidle: TIDLE

        /// Clock timeout enable
        @ReadWrite(bits: 15..<16)
        public var timouten: TIMOUTEN

        /// Note: These bits can be written only when TEXTEN=0.
        @ReadWrite(bits: 16..<28)
        public var timeoutb: TIMEOUTB

        /// Extended clock timeout enable
        @ReadWrite(bits: 31..<32)
        public var texten: TEXTEN
    }

    /// I2C interrupt and status register
    @Register(bitWidth: 32)
    public struct ISR {
        /// Note: This bit is set by hardware when PE=0.
        @ReadWrite(bits: 0..<1)
        public var txe: TXE

        /// Note: This bit is cleared by hardware when PE=0.
        @ReadWrite(bits: 1..<2)
        public var txis: TXIS

        /// Note: This bit is cleared by hardware when PE=0.
        @ReadOnly(bits: 2..<3)
        public var rxne: RXNE

        /// Note: This bit is cleared by hardware when PE=0.
        @ReadOnly(bits: 3..<4)
        public var addr: ADDR

        /// Note: This bit is cleared by hardware when PE=0.
        @ReadOnly(bits: 4..<5)
        public var nackf: NACKF

        /// Note: This bit is cleared by hardware when PE=0.
        @ReadOnly(bits: 5..<6)
        public var stopf: STOPF

        /// Note: This bit is cleared by hardware when PE=0.
        @ReadOnly(bits: 6..<7)
        public var tc: TC

        /// This flag is only for master mode, or for slave mode when the SBC bit is set.
        @ReadOnly(bits: 7..<8)
        public var tcr: TCR

        /// Note: This bit is cleared by hardware when PE=0.
        @ReadOnly(bits: 8..<9)
        public var berr: BERR

        /// Note: This bit is cleared by hardware when PE=0.
        @ReadOnly(bits: 9..<10)
        public var arlo: ARLO

        /// Note: This bit is cleared by hardware when PE=0.
        @ReadOnly(bits: 10..<11)
        public var ovr: OVR

        /// If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .
        @ReadOnly(bits: 11..<12)
        public var pecerr: PECERR

        /// If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .
        @ReadOnly(bits: 12..<13)
        public var timeout: TIMEOUT

        /// If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .
        @ReadOnly(bits: 13..<14)
        public var alert: ALERT

        /// This flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected. It is cleared by hardware when a STOP condition is detected, or when PE=0.
        @ReadOnly(bits: 15..<16)
        public var busy: BUSY

        /// This flag is updated when an address match event occurs (ADDR=1).
        @ReadOnly(bits: 16..<17)
        public var dir: DIR

        /// In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 MSBs of the address.
        @ReadOnly(bits: 17..<24)
        public var addcode: ADDCODE
    }

    /// I2C interrupt clear register
    @Register(bitWidth: 32)
    public struct ICR {
        /// Writing 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register.
        @WriteOnly(bits: 3..<4)
        public var addrcf: ADDRCF

        /// Writing 1 to this bit clears the NACKF flag in I2C_ISR register.
        @WriteOnly(bits: 4..<5)
        public var nackcf: NACKCF

        /// Writing 1 to this bit clears the STOPF flag in the I2C_ISR register.
        @WriteOnly(bits: 5..<6)
        public var stopcf: STOPCF

        /// Writing 1 to this bit clears the BERRF flag in the I2C_ISR register.
        @WriteOnly(bits: 8..<9)
        public var berrcf: BERRCF

        /// Writing 1 to this bit clears the ARLO flag in the I2C_ISR register.
        @WriteOnly(bits: 9..<10)
        public var arlocf: ARLOCF

        /// Writing 1 to this bit clears the OVR flag in the I2C_ISR register.
        @WriteOnly(bits: 10..<11)
        public var ovrcf: OVRCF

        /// Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .
        @WriteOnly(bits: 11..<12)
        public var peccf: PECCF

        /// Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .
        @WriteOnly(bits: 12..<13)
        public var timoutcf: TIMOUTCF

        /// Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to ‘0’. Refer to .
        @WriteOnly(bits: 13..<14)
        public var alertcf: ALERTCF
    }

    /// I2C PEC register
    @Register(bitWidth: 32)
    public struct PECR {
        /// The PEC is cleared by hardware when PE=0.
        @ReadOnly(bits: 0..<8)
        public var pec: PEC
    }

    /// I2C receive data register
    @Register(bitWidth: 32)
    public struct RXDR {
        /// Data byte received from the I2C bus
        @ReadOnly(bits: 0..<8)
        public var rxdata: RXDATA
    }

    /// I2C transmit data register
    @Register(bitWidth: 32)
    public struct TXDR {
        /// Note: These bits can be written only when TXE=1.
        @ReadWrite(bits: 0..<8)
        public var txdata: TXDATA
    }
}

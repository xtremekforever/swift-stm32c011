// Generated by svd2swift.

import MMIO

/// RCC address block description
@RegisterBlock
public struct RCC: Sendable {
    /// RCC clock control register
    @RegisterBlock(offset: 0x0)
    public var cr: Register<CR>

    /// RCC internal clock source calibration register
    @RegisterBlock(offset: 0x4)
    public var icscr: Register<ICSCR>

    /// RCC clock configuration register
    @RegisterBlock(offset: 0x8)
    public var cfgr: Register<CFGR>

    /// RCC clock interrupt enable register
    @RegisterBlock(offset: 0x18)
    public var cier: Register<CIER>

    /// RCC clock interrupt flag register
    @RegisterBlock(offset: 0x1c)
    public var cifr: Register<CIFR>

    /// RCC clock interrupt clear register
    @RegisterBlock(offset: 0x20)
    public var cicr: Register<CICR>

    /// RCC I/O port reset register
    @RegisterBlock(offset: 0x24)
    public var ioprstr: Register<IOPRSTR>

    /// RCC AHB peripheral reset register
    @RegisterBlock(offset: 0x28)
    public var ahbrstr: Register<AHBRSTR>

    /// RCC APB peripheral reset register 1
    @RegisterBlock(offset: 0x2c)
    public var apbrstr1: Register<APBRSTR1>

    /// RCC APB peripheral reset register 2
    @RegisterBlock(offset: 0x30)
    public var apbrstr2: Register<APBRSTR2>

    /// RCC I/O port clock enable register
    @RegisterBlock(offset: 0x34)
    public var iopenr: Register<IOPENR>

    /// RCC AHB peripheral clock enable register
    @RegisterBlock(offset: 0x38)
    public var ahbenr: Register<AHBENR>

    /// RCC APB peripheral clock enable register 1
    @RegisterBlock(offset: 0x3c)
    public var apbenr1: Register<APBENR1>

    /// RCC APB peripheral clock enable register 2
    @RegisterBlock(offset: 0x40)
    public var apbenr2: Register<APBENR2>

    /// RCC I/O port in Sleep mode clock enable register
    @RegisterBlock(offset: 0x44)
    public var iopsmenr: Register<IOPSMENR>

    /// RCC AHB peripheral clock enable in Sleep/Stop mode register
    @RegisterBlock(offset: 0x48)
    public var ahbsmenr: Register<AHBSMENR>

    /// RCC APB peripheral clock enable in Sleep/Stop mode register 1
    @RegisterBlock(offset: 0x4c)
    public var apbsmenr1: Register<APBSMENR1>

    /// RCC APB peripheral clock enable in Sleep/Stop mode register 2
    @RegisterBlock(offset: 0x50)
    public var apbsmenr2: Register<APBSMENR2>

    /// RCC peripherals independent clock configuration register
    @RegisterBlock(offset: 0x54)
    public var ccipr: Register<CCIPR>

    /// RCC control/status register 1
    @RegisterBlock(offset: 0x5c)
    public var csr1: Register<CSR1>

    /// RCC control/status register 2
    @RegisterBlock(offset: 0x60)
    public var csr2: Register<CSR2>
}

extension RCC {
    /// RCC clock control register
    @Register(bitWidth: 32)
    public struct CR {
        /// This bitfield controlled by software sets the division factor of the system clock divider to produce SYSCLK clock:
        @ReadWrite(bits: 2..<5)
        public var sysdiv: SYSDIV

        /// This bitfield controlled by software sets the division factor of the kernel clock divider to produce HSIKER clock:
        @ReadWrite(bits: 5..<8)
        public var hsikerdiv: HSIKERDIV

        /// Kept high by hardware as long as the system is clocked with a clock derived from HSI48. This includes the exit from low-power modes and the system clock fall-back to HSI48 upon failing HSE oscillator clock selected as system clock source.
        @ReadWrite(bits: 8..<9)
        public var hsion: HSION

        /// Note: Keeping the HSI48 active in Stop mode allows speeding up the serial interface communication as the HSI48 clock is ready immediately upon exiting Stop mode.
        @ReadWrite(bits: 9..<10)
        public var hsikeron: HSIKERON

        /// Note: Upon clearing HSION, HSIRDY goes low after six HSI48 clock cycles.
        @ReadOnly(bits: 10..<11)
        public var hsirdy: HSIRDY

        /// This bitfield controlled by software sets the division factor of the HSI48 clock divider to produce HSISYS clock:
        @ReadWrite(bits: 11..<14)
        public var hsidiv: HSIDIV

        /// Cleared by hardware to stop the HSE oscillator when entering Stop, or Standby, or Shutdown mode. This bit cannot be cleared if the HSE oscillator is used directly or indirectly as the system clock.
        @ReadWrite(bits: 16..<17)
        public var hseon: HSEON

        /// Note: Upon clearing HSEON, HSERDY goes low after six HSE clock cycles.
        @ReadOnly(bits: 17..<18)
        public var hserdy: HSERDY

        /// When the bit is set, the internal HSE oscillator is bypassed for use of an external clock. The external clock must then be enabled with the HSEON bit set. Write access to the bit is only effective when the HSE oscillator is disabled.
        @ReadWrite(bits: 18..<19)
        public var hsebyp: HSEBYP

        /// Set by software to enable the clock security system. When the bit is set, the clock detector is enabled by hardware when the HSE oscillator is ready, and disabled by hardware if a HSE clock failure is detected. The bit is cleared by hardware upon reset.
        @ReadWrite(bits: 19..<20)
        public var csson: CSSON
    }

    /// RCC internal clock source calibration register
    @Register(bitWidth: 32)
    public struct ICSCR {
        /// Note: The trimming effect presents discontinuities at HSICAL[7:0] multiples of 64.
        @ReadOnly(bits: 0..<8)
        public var hsical: HSICAL

        /// The HSI48 frequency accuracy as stated in the device datasheet applies when this bitfield is left at its reset value.
        @ReadWrite(bits: 8..<15)
        public var hsitrim: HSITRIM
    }

    /// RCC clock configuration register
    @Register(bitWidth: 32)
    public struct CFGR {
        /// The setting is forced by hardware to 000 (HSISYS selected) when the MCU exits Stop, or Standby, or Shutdown mode, or when the setting is 001 (HSE selected) and HSE oscillator failure is detected.
        @ReadWrite(bits: 0..<3)
        public var sw: SW

        /// Others: Reserved
        @ReadOnly(bits: 3..<6)
        public var sws: SWS

        /// 0xxx: 1
        @ReadWrite(bits: 8..<12)
        public var hpre: HPRE

        /// 0xx: 1
        @ReadWrite(bits: 12..<15)
        public var ppre: PPRE

        /// Note: This clock output may have some truncated cycles at startup or during MCO2 clock source switching.
        @ReadWrite(bits: 16..<20)
        public var mco2sel: MCO2SEL

        /// It is highly recommended to set this field before the MCO2 output is enabled.
        @ReadWrite(bits: 20..<24)
        public var mco2pre: MCO2PRE

        /// Note: This clock output may have some truncated cycles at startup or during MCO clock source switching. Any other value means no clock on MCO.
        @ReadWrite(bits: 24..<28)
        public var mcosel: MCOSEL

        /// It is highly recommended to set this field before the MCO output is enabled.
        @ReadWrite(bits: 28..<32)
        public var mcopre: MCOPRE
    }

    /// RCC clock interrupt enable register
    @Register(bitWidth: 32)
    public struct CIER {
        /// Set and cleared by software to enable/disable interrupt caused by the LSI oscillator stabilization:
        @ReadWrite(bits: 0..<1)
        public var lsirdyie: LSIRDYIE

        /// Set and cleared by software to enable/disable interrupt caused by the LSE oscillator stabilization:
        @ReadWrite(bits: 1..<2)
        public var lserdyie: LSERDYIE

        /// Set and cleared by software to enable/disable interrupt caused by the HSI16 oscillator stabilization:
        @ReadWrite(bits: 3..<4)
        public var hsirdyie: HSIRDYIE

        /// Set and cleared by software to enable/disable interrupt caused by the HSE oscillator stabilization:
        @ReadWrite(bits: 4..<5)
        public var hserdyie: HSERDYIE
    }

    /// RCC clock interrupt flag register
    @Register(bitWidth: 32)
    public struct CIFR {
        /// Cleared by software setting the LSIRDYC bit.
        @ReadOnly(bits: 0..<1)
        public var lsirdyf: LSIRDYF

        /// Cleared by software setting the LSERDYC bit.
        @ReadOnly(bits: 1..<2)
        public var lserdyf: LSERDYF

        /// Cleared by software setting the HSIRDYC bit.
        @ReadOnly(bits: 3..<4)
        public var hsirdyf: HSIRDYF

        /// Cleared by software setting the HSERDYC bit.
        @ReadOnly(bits: 4..<5)
        public var hserdyf: HSERDYF

        /// Cleared by software setting the CSSC bit.
        @ReadOnly(bits: 8..<9)
        public var cssf: CSSF

        /// Cleared by software by setting the LSECSSC bit.
        @ReadOnly(bits: 9..<10)
        public var lsecssf: LSECSSF
    }

    /// RCC clock interrupt clear register
    @Register(bitWidth: 32)
    public struct CICR {
        /// This bit is set by software to clear the LSIRDYF flag.
        @WriteOnly(bits: 0..<1)
        public var lsirdyc: LSIRDYC

        /// This bit is set by software to clear the LSERDYF flag.
        @WriteOnly(bits: 1..<2)
        public var lserdyc: LSERDYC

        /// This bit is set software to clear the HSIRDYF flag.
        @WriteOnly(bits: 3..<4)
        public var hsirdyc: HSIRDYC

        /// This bit is set by software to clear the HSERDYF flag.
        @WriteOnly(bits: 4..<5)
        public var hserdyc: HSERDYC

        /// This bit is set by software to clear the HSECSSF flag.
        @WriteOnly(bits: 8..<9)
        public var cssc: CSSC

        /// This bit is set by software to clear the LSECSSF flag.
        @WriteOnly(bits: 9..<10)
        public var lsecssc: LSECSSC
    }

    /// RCC I/O port reset register
    @Register(bitWidth: 32)
    public struct IOPRSTR {
        /// This bit is set and cleared by software.
        @ReadWrite(bits: 0..<1)
        public var gpioarst: GPIOARST

        /// This bit is set and cleared by software.
        @ReadWrite(bits: 1..<2)
        public var gpiobrst: GPIOBRST

        /// This bit is set and cleared by software.
        @ReadWrite(bits: 2..<3)
        public var gpiocrst: GPIOCRST

        /// This bit is set and cleared by software.
        @ReadWrite(bits: 3..<4)
        public var gpiodrst: GPIODRST

        /// This bit is set and cleared by software.
        @ReadWrite(bits: 5..<6)
        public var gpiofrst: GPIOFRST
    }

    /// RCC AHB peripheral reset register
    @Register(bitWidth: 32)
    public struct AHBRSTR {
        /// Set and cleared by software.
        @ReadWrite(bits: 0..<1)
        public var dma1rst: DMA1RST

        /// This bit can only be set when the Flash memory is in power down mode.
        @ReadWrite(bits: 8..<9)
        public var flashrst: FLASHRST

        /// Set and cleared by software.
        @ReadWrite(bits: 12..<13)
        public var crcrst: CRCRST
    }

    /// RCC APB peripheral reset register 1
    @Register(bitWidth: 32)
    public struct APBRSTR1 {
        /// Set and cleared by software.
        @ReadWrite(bits: 1..<2)
        public var tim3rst: TIM3RST

        /// Set and cleared by software.
        @ReadWrite(bits: 17..<18)
        public var usart2rst: USART2RST

        /// Set and cleared by software.
        @ReadWrite(bits: 21..<22)
        public var i2c1rst: I2C1RST

        /// Set and cleared by software.
        @ReadWrite(bits: 27..<28)
        public var dbgrst: DBGRST

        /// Set and cleared by software.
        @ReadWrite(bits: 28..<29)
        public var pwrrst: PWRRST
    }

    /// RCC APB peripheral reset register 2
    @Register(bitWidth: 32)
    public struct APBRSTR2 {
        /// Set and cleared by software.
        @ReadWrite(bits: 0..<1)
        public var syscfgrst: SYSCFGRST

        /// Set and cleared by software.
        @ReadWrite(bits: 11..<12)
        public var tim1rst: TIM1RST

        /// Set and cleared by software.
        @ReadWrite(bits: 12..<13)
        public var spi1rst: SPI1RST

        /// Set and cleared by software.
        @ReadWrite(bits: 14..<15)
        public var usart1rst: USART1RST

        /// Set and cleared by software.
        @ReadWrite(bits: 15..<16)
        public var tim14rst: TIM14RST

        /// Set and cleared by software.
        @ReadWrite(bits: 17..<18)
        public var tim16rst: TIM16RST

        /// Set and cleared by software.
        @ReadWrite(bits: 18..<19)
        public var tim17rst: TIM17RST

        /// Set and cleared by software.
        @ReadWrite(bits: 20..<21)
        public var adcrst: ADCRST
    }

    /// RCC I/O port clock enable register
    @Register(bitWidth: 32)
    public struct IOPENR {
        /// This bit is set and cleared by software.
        @ReadWrite(bits: 0..<1)
        public var gpioaen: GPIOAEN

        /// This bit is set and cleared by software.
        @ReadWrite(bits: 1..<2)
        public var gpioben: GPIOBEN

        /// This bit is set and cleared by software.
        @ReadWrite(bits: 2..<3)
        public var gpiocen: GPIOCEN

        /// This bit is set and cleared by software.
        @ReadWrite(bits: 3..<4)
        public var gpioden: GPIODEN

        /// This bit is set and cleared by software.
        @ReadWrite(bits: 5..<6)
        public var gpiofen: GPIOFEN
    }

    /// RCC AHB peripheral clock enable register
    @Register(bitWidth: 32)
    public struct AHBENR {
        /// DMAMUX is enabled as long as at least one DMA peripheral is enabled.
        @ReadWrite(bits: 0..<1)
        public var dma1en: DMA1EN

        /// This bit can only be cleared when the Flash memory is in power down mode.
        @ReadWrite(bits: 8..<9)
        public var flashen: FLASHEN

        /// Set and cleared by software.
        @ReadWrite(bits: 12..<13)
        public var crcen: CRCEN
    }

    /// RCC APB peripheral clock enable register 1
    @Register(bitWidth: 32)
    public struct APBENR1 {
        /// Set and cleared by software.
        @ReadWrite(bits: 1..<2)
        public var tim3en: TIM3EN

        /// Set and cleared by software.
        @ReadWrite(bits: 10..<11)
        public var rtcapben: RTCAPBEN

        /// This bit can also be set by hardware if the WWDG_SW option bit is 0.
        @ReadWrite(bits: 11..<12)
        public var wwdgen: WWDGEN

        /// Set and cleared by software.
        @ReadWrite(bits: 17..<18)
        public var usart2en: USART2EN

        /// Set and cleared by software.
        @ReadWrite(bits: 21..<22)
        public var i2c1en: I2C1EN

        /// Set and cleared by software.
        @ReadWrite(bits: 27..<28)
        public var dbgen: DBGEN

        /// Set and cleared by software.
        @ReadWrite(bits: 28..<29)
        public var pwren: PWREN
    }

    /// RCC APB peripheral clock enable register 2
    @Register(bitWidth: 32)
    public struct APBENR2 {
        /// Set and cleared by software.
        @ReadWrite(bits: 0..<1)
        public var syscfgen: SYSCFGEN

        /// Set and cleared by software.
        @ReadWrite(bits: 11..<12)
        public var tim1en: TIM1EN

        /// Set and cleared by software.
        @ReadWrite(bits: 12..<13)
        public var spi1en: SPI1EN

        /// Set and cleared by software.
        @ReadWrite(bits: 14..<15)
        public var usart1en: USART1EN

        /// Set and cleared by software.
        @ReadWrite(bits: 15..<16)
        public var tim14en: TIM14EN

        /// Set and cleared by software.
        @ReadWrite(bits: 17..<18)
        public var tim16en: TIM16EN

        /// Set and cleared by software.
        @ReadWrite(bits: 18..<19)
        public var tim17en: TIM17EN

        /// Set and cleared by software.
        @ReadWrite(bits: 20..<21)
        public var adcen: ADCEN
    }

    /// RCC I/O port in Sleep mode clock enable register
    @Register(bitWidth: 32)
    public struct IOPSMENR {
        /// Set and cleared by software.
        @ReadWrite(bits: 0..<1)
        public var gpioasmen: GPIOASMEN

        /// Set and cleared by software.
        @ReadWrite(bits: 1..<2)
        public var gpiobsmen: GPIOBSMEN

        /// Set and cleared by software.
        @ReadWrite(bits: 2..<3)
        public var gpiocsmen: GPIOCSMEN

        /// Set and cleared by software.
        @ReadWrite(bits: 3..<4)
        public var gpiodsmen: GPIODSMEN

        /// Set and cleared by software.
        @ReadWrite(bits: 5..<6)
        public var gpiofsmen: GPIOFSMEN
    }

    /// RCC AHB peripheral clock enable in Sleep/Stop mode register
    @Register(bitWidth: 32)
    public struct AHBSMENR {
        /// Clock to DMAMUX during Sleep mode is enabled as long as the clock in Sleep mode is enabled to at least one DMA peripheral.
        @ReadWrite(bits: 0..<1)
        public var dma1smen: DMA1SMEN

        /// This bit can be activated only when the Flash memory is in power down mode.
        @ReadWrite(bits: 8..<9)
        public var flashsmen: FLASHSMEN

        /// Set and cleared by software.
        @ReadWrite(bits: 9..<10)
        public var sramsmen: SRAMSMEN

        /// Set and cleared by software.
        @ReadWrite(bits: 12..<13)
        public var crcsmen: CRCSMEN
    }

    /// RCC APB peripheral clock enable in Sleep/Stop mode register 1
    @Register(bitWidth: 32)
    public struct APBSMENR1 {
        /// Set and cleared by software.
        @ReadWrite(bits: 1..<2)
        public var tim3smen: TIM3SMEN

        /// Set and cleared by software.
        @ReadWrite(bits: 10..<11)
        public var rtcapbsmen: RTCAPBSMEN

        /// Set and cleared by software.
        @ReadWrite(bits: 11..<12)
        public var wwdgsmen: WWDGSMEN

        /// Set and cleared by software.
        @ReadWrite(bits: 17..<18)
        public var usart2smen: USART2SMEN

        /// Set and cleared by software.
        @ReadWrite(bits: 21..<22)
        public var i2c1smen: I2C1SMEN

        /// Set and cleared by software.
        @ReadWrite(bits: 27..<28)
        public var dbgsmen: DBGSMEN

        /// Set and cleared by software.
        @ReadWrite(bits: 28..<29)
        public var pwrsmen: PWRSMEN
    }

    /// RCC APB peripheral clock enable in Sleep/Stop mode register 2
    @Register(bitWidth: 32)
    public struct APBSMENR2 {
        /// Set and cleared by software.
        @ReadWrite(bits: 0..<1)
        public var syscfgsmen: SYSCFGSMEN

        /// Set and cleared by software.
        @ReadWrite(bits: 11..<12)
        public var tim1smen: TIM1SMEN

        /// Set and cleared by software.
        @ReadWrite(bits: 12..<13)
        public var spi1smen: SPI1SMEN

        /// Set and cleared by software.
        @ReadWrite(bits: 14..<15)
        public var usart1smen: USART1SMEN

        /// Set and cleared by software.
        @ReadWrite(bits: 15..<16)
        public var tim14smen: TIM14SMEN

        /// Set and cleared by software.
        @ReadWrite(bits: 17..<18)
        public var tim16smen: TIM16SMEN

        /// Set and cleared by software.
        @ReadWrite(bits: 18..<19)
        public var tim17smen: TIM17SMEN

        /// Set and cleared by software.
        @ReadWrite(bits: 20..<21)
        public var adcsmen: ADCSMEN
    }

    /// RCC peripherals independent clock configuration register
    @Register(bitWidth: 32)
    public struct CCIPR {
        /// This bitfield is controlled by software to select USART1 clock source as follows:
        @ReadWrite(bits: 0..<2)
        public var usart1sel: USART1SEL

        /// This bitfield is controlled by software to select I2C1 clock source as follows:
        @ReadWrite(bits: 12..<14)
        public var i2c1sel: I2C1SEL

        /// This bitfield is controlled by software to select I2S1 clock source as follows:
        @ReadWrite(bits: 14..<16)
        public var i2s1sel: I2S1SEL

        /// This bitfield is controlled by software to select the clock source for ADC:
        @ReadWrite(bits: 30..<32)
        public var adcsel: ADCSEL
    }

    /// RCC control/status register 1
    @Register(bitWidth: 32)
    public struct CSR1 {
        /// Set and cleared by software to enable LSE oscillator:
        @ReadWrite(bits: 0..<1)
        public var lseon: LSEON

        /// After the LSEON bit is cleared, LSERDY goes low after 6 external low-speed oscillator clock cycles.
        @ReadOnly(bits: 1..<2)
        public var lserdy: LSERDY

        /// This bit can be written only when the external 32 kHz oscillator is disabled (LSEON=0 and LSERDY=0).
        @ReadWrite(bits: 2..<3)
        public var lsebyp: LSEBYP

        /// Applicable when the LSE oscillator is in Xtal mode, as opposed to bypass mode.
        @ReadWrite(bits: 3..<5)
        public var lsedrv: LSEDRV

        /// =1). In that case the software must disable the LSECSSON bit.
        @ReadWrite(bits: 5..<6)
        public var lsecsson: LSECSSON

        /// on the external 32 kHz oscillator (LSE):
        @ReadOnly(bits: 6..<7)
        public var lsecssd: LSECSSD

        /// Once the RTC clock source is selected, it cannot be changed anymore unless the RTC domain is reset, or unless a failure is detected on LSE (LSECSSD is set). The RTCRST bit can be used to reset this bitfield to 00.
        @ReadWrite(bits: 8..<10)
        public var rtcsel: RTCSEL

        /// Set and cleared by software. The bit enables clock to RTC and TAMP.
        @ReadWrite(bits: 15..<16)
        public var rtcen: RTCEN

        /// Set and cleared by software to reset the RTC domain:
        @ReadWrite(bits: 16..<17)
        public var rtcrst: RTCRST

        /// Set and cleared by software.
        @ReadWrite(bits: 24..<25)
        public var lscoen: LSCOEN

        /// Set and cleared by software to select the low-speed output clock:
        @ReadWrite(bits: 25..<26)
        public var lscosel: LSCOSEL
    }

    /// RCC control/status register 2
    @Register(bitWidth: 32)
    public struct CSR2 {
        /// Set and cleared by software to enable/disable the LSI oscillator:
        @ReadWrite(bits: 0..<1)
        public var lsion: LSION

        /// After the LSION bit is cleared, LSIRDY goes low after 3 LSI oscillator clock cycles. This bit can be set even if LSION = 0 if the LSI is requested by the Clock Security System on LSE, by the Independent Watchdog or by the RTC.
        @ReadOnly(bits: 1..<2)
        public var lsirdy: LSIRDY

        /// Set by software to clear the reset flags.
        @ReadWrite(bits: 23..<24)
        public var rmvf: RMVF

        /// Cleared by setting the RMVF bit.
        @ReadOnly(bits: 25..<26)
        public var oblrstf: OBLRSTF

        /// Cleared by setting the RMVF bit.
        @ReadOnly(bits: 26..<27)
        public var pinrstf: PINRSTF

        /// Cleared by setting the RMVF bit.
        @ReadOnly(bits: 27..<28)
        public var pwrrstf: PWRRSTF

        /// Cleared by setting the RMVF bit.
        @ReadOnly(bits: 28..<29)
        public var sftrstf: SFTRSTF

        /// Cleared by setting the RMVF bit.
        @ReadOnly(bits: 29..<30)
        public var iwdgrstf: IWDGRSTF

        /// Cleared by setting the RMVF bit.
        @ReadOnly(bits: 30..<31)
        public var wwdgrstf: WWDGRSTF

        /// This operates only if nRST_STOP, or nRST_STDBY or nRST_SHDW option bits are cleared.
        @ReadOnly(bits: 31..<32)
        public var lpwrrstf: LPWRRSTF
    }
}

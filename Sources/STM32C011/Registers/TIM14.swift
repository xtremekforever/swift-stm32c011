// Generated by svd2swift.

import MMIO

/// General-purpose timers
@RegisterBlock
public struct TIM14: Sendable {
    /// TIM14 control register 1
    @RegisterBlock(offset: 0x0)
    public var cr1: Register<CR1>

    /// TIM14 Interrupt enable register
    @RegisterBlock(offset: 0xc)
    public var dier: Register<DIER>

    /// TIM14 status register
    @RegisterBlock(offset: 0x10)
    public var sr: Register<SR>

    /// TIM14 event generation register
    @RegisterBlock(offset: 0x14)
    public var egr: Register<EGR>

    /// TIM14 capture/compare mode register 1 [alternate]
    @RegisterBlock(offset: 0x18)
    public var ccmr1_input: Register<CCMR1_input>

    /// TIM14 capture/compare mode register 1 [alternate]
    @RegisterBlock(offset: 0x18)
    public var ccmr1_output: Register<CCMR1_output>

    /// TIM14 capture/compare enable register
    @RegisterBlock(offset: 0x20)
    public var ccer: Register<CCER>

    /// TIM14 counter
    @RegisterBlock(offset: 0x24)
    public var cnt: Register<CNT>

    /// TIM14 prescaler
    @RegisterBlock(offset: 0x28)
    public var psc: Register<PSC>

    /// TIM14 auto-reload register
    @RegisterBlock(offset: 0x2c)
    public var arr: Register<ARR>

    /// TIM14 capture/compare register 1
    @RegisterBlock(offset: 0x34)
    public var ccr1: Register<CCR1>

    /// TIM14 timer input selection register
    @RegisterBlock(offset: 0x68)
    public var tisel: Register<TISEL>
}

extension TIM14 {
    /// TIM14 control register 1
    @Register(bitWidth: 16)
    public struct CR1 {
        /// software. However trigger mode can set the CEN bit automatically by hardware.
        @ReadWrite(bits: 0..<1)
        public var cen: CEN

        /// Buffered registers are then loaded with their preload values.
        @ReadWrite(bits: 1..<2)
        public var udis: UDIS

        /// Setting the UG bit
        @ReadWrite(bits: 2..<3)
        public var urs: URS

        /// One-pulse mode
        @ReadWrite(bits: 3..<4)
        public var opm: OPM

        /// Auto-reload preload enable
        @ReadWrite(bits: 7..<8)
        public var arpe: ARPE

        /// This bit-field indicates the division ratio between the timer clock (CK_INT) frequency and sampling clock used by the digital filters (TIx),
        @ReadWrite(bits: 8..<10)
        public var ckd: CKD

        /// UIF status bit remapping
        @ReadWrite(bits: 11..<12)
        public var uifremap: UIFREMAP
    }

    /// TIM14 Interrupt enable register
    @Register(bitWidth: 16)
    public struct DIER {
        /// Update interrupt enable
        @ReadWrite(bits: 0..<1)
        public var uie: UIE

        /// Capture/Compare 1 interrupt enable
        @ReadWrite(bits: 1..<2)
        public var cc1ie: CC1IE
    }

    /// TIM14 status register
    @Register(bitWidth: 16)
    public struct SR {
        /// When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=’0’ and UDIS=’0’ in the TIMx_CR1 register.
        @ReadWrite(bits: 0..<1)
        public var uif: UIF

        /// If channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER).
        @ReadWrite(bits: 1..<2)
        public var cc1if: CC1IF

        /// This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to ‘0’.
        @ReadWrite(bits: 9..<10)
        public var cc1of: CC1OF
    }

    /// TIM14 event generation register
    @Register(bitWidth: 16)
    public struct EGR {
        /// This bit can be set by software, it is automatically cleared by hardware.
        @WriteOnly(bits: 0..<1)
        public var ug: UG

        /// The current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.
        @WriteOnly(bits: 1..<2)
        public var cc1g: CC1G
    }

    /// TIM14 capture/compare mode register 1 [alternate]
    @Register(bitWidth: 32)
    public struct CCMR1_input {
        /// Note: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).
        @ReadWrite(bits: 0..<2)
        public var cc1s: CC1S

        /// The prescaler is reset as soon as CC1E=’0’ (TIMx_CCER register).
        @ReadWrite(bits: 2..<4)
        public var ic1psc: IC1PSC

        /// This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:
        @ReadWrite(bits: 4..<8)
        public var ic1f: IC1F
    }

    /// TIM14 capture/compare mode register 1 [alternate]
    @Register(bitWidth: 32)
    public struct CCMR1_output {
        /// Note: CC1S bits are writable only when the channel is OFF (CC1E = 0 in TIMx_CCER).
        @ReadWrite(bits: 0..<2)
        public var cc1s: CC1S

        /// This bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the starting trigger.
        @ReadWrite(bits: 2..<3)
        public var oc1fe: OC1FE

        /// Note: The PWM mode can be used without validating the preload register only in one pulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed.
        @ReadWrite(bits: 3..<4)
        public var oc1pe: OC1PE

        /// Note: The OC1M[3] bit is not contiguous, located in bit 16.
        @ReadWrite(bits: 4..<7)
        public var oc1m1: OC1M1

        /// Note: The OC1M[3] bit is not contiguous, located in bit 16.
        @ReadWrite(bits: 16..<17)
        public var oc1m2: OC1M2
    }

    /// TIM14 capture/compare enable register
    @Register(bitWidth: 16)
    public struct CCER {
        /// Capture/Compare 1 output enable.
        @ReadWrite(bits: 0..<1)
        public var cc1e: CC1E

        /// CC1NP=1, CC1P=0:	This configuration is reserved, it must not be used.
        @ReadWrite(bits: 1..<2)
        public var cc1p: CC1P

        /// CC1 channel configured as input: CC1NP bit is used in conjunction with CC1P to define TI1FP1 polarity (refer to CC1P description).
        @ReadWrite(bits: 3..<4)
        public var cc1np: CC1NP
    }

    /// TIM14 counter
    @Register(bitWidth: 32)
    public struct CNT {
        /// Counter value
        @ReadWrite(bits: 0..<16)
        public var cnt_field: CNT_FIELD

        /// This bit is a read-only copy of the UIF bit in the TIMx_ISR register.
        @ReadWrite(bits: 31..<32)
        public var uifcpy: UIFCPY
    }

    /// TIM14 prescaler
    @Register(bitWidth: 16)
    public struct PSC {
        /// (including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in “reset mode”).
        @ReadWrite(bits: 0..<16)
        public var psc_field: PSC_FIELD
    }

    /// TIM14 auto-reload register
    @Register(bitWidth: 16)
    public struct ARR {
        /// The counter is blocked while the auto-reload value is null.
        @ReadWrite(bits: 0..<16)
        public var arr_field: ARR_FIELD
    }

    /// TIM14 capture/compare register 1
    @Register(bitWidth: 16)
    public struct CCR1 {
        /// CCR1 is the counter value transferred by the last input capture 1 event (IC1).
        @ReadWrite(bits: 0..<16)
        public var ccr1_field: CCR1_FIELD
    }

    /// TIM14 timer input selection register
    @Register(bitWidth: 16)
    public struct TISEL {
        /// Others: Reserved
        @ReadWrite(bits: 0..<4)
        public var ti1sel: TI1SEL
    }
}

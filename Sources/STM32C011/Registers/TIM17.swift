// Generated by svd2swift.

import MMIO

/// General-purpose timers
@RegisterBlock
public struct TIM17: Sendable {
    /// TIM17 control register 1
    @RegisterBlock(offset: 0x0)
    public var cr1: Register<CR1>

    /// TIM17 control register 2
    @RegisterBlock(offset: 0x4)
    public var cr2: Register<CR2>

    /// TIM17 DMA/interrupt enable register
    @RegisterBlock(offset: 0xc)
    public var dier: Register<DIER>

    /// TIM17 status register
    @RegisterBlock(offset: 0x10)
    public var sr: Register<SR>

    /// TIM17 event generation register
    @RegisterBlock(offset: 0x14)
    public var egr: Register<EGR>

    /// TIM17 capture/compare mode register 1 [alternate]
    @RegisterBlock(offset: 0x18)
    public var ccmr1_input: Register<CCMR1_input>

    /// TIM17 capture/compare mode register 1 [alternate]
    @RegisterBlock(offset: 0x18)
    public var ccmr1_output: Register<CCMR1_output>

    /// TIM17 capture/compare enable register
    @RegisterBlock(offset: 0x20)
    public var ccer: Register<CCER>

    /// TIM17 counter
    @RegisterBlock(offset: 0x24)
    public var cnt: Register<CNT>

    /// TIM17 prescaler
    @RegisterBlock(offset: 0x28)
    public var psc: Register<PSC>

    /// TIM17 auto-reload register
    @RegisterBlock(offset: 0x2c)
    public var arr: Register<ARR>

    /// TIM17 repetition counter register
    @RegisterBlock(offset: 0x30)
    public var rcr: Register<RCR>

    /// TIM17 capture/compare register 1
    @RegisterBlock(offset: 0x34)
    public var ccr1: Register<CCR1>

    /// TIM17 break and dead-time register
    @RegisterBlock(offset: 0x44)
    public var bdtr: Register<BDTR>

    /// TIM17 DMA control register
    @RegisterBlock(offset: 0x48)
    public var dcr: Register<DCR>

    /// TIM17 DMA address for full transfer
    @RegisterBlock(offset: 0x4c)
    public var dmar: Register<DMAR>

    /// TIM17 alternate function register 1
    @RegisterBlock(offset: 0x60)
    public var af1: Register<AF1>

    /// TIM17 input selection register
    @RegisterBlock(offset: 0x68)
    public var tisel: Register<TISEL>
}

extension TIM17 {
    /// TIM17 control register 1
    @Register(bitWidth: 16)
    public struct CR1 {
        /// Note: External clock and gated mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.
        @ReadWrite(bits: 0..<1)
        public var cen: CEN

        /// Buffered registers are then loaded with their preload values.
        @ReadWrite(bits: 1..<2)
        public var udis: UDIS

        /// Update generation through the slave mode controller
        @ReadWrite(bits: 2..<3)
        public var urs: URS

        /// One pulse mode
        @ReadWrite(bits: 3..<4)
        public var opm: OPM

        /// Auto-reload preload enable
        @ReadWrite(bits: 7..<8)
        public var arpe: ARPE

        /// This bit-field indicates the division ratio between the timer clock (CK_INT) frequency and the dead-time and sampling clock (tDTS)used by the dead-time generators and the digital filters (TIx),
        @ReadWrite(bits: 8..<10)
        public var ckd: CKD

        /// UIF status bit remapping
        @ReadWrite(bits: 11..<12)
        public var uifremap: UIFREMAP
    }

    /// TIM17 control register 2
    @Register(bitWidth: 16)
    public struct CR2 {
        /// Note: This bit acts only on channels that have a complementary output.
        @ReadWrite(bits: 0..<1)
        public var ccpc: CCPC

        /// Note: This bit acts only on channels that have a complementary output.
        @ReadWrite(bits: 2..<3)
        public var ccus: CCUS

        /// Capture/compare DMA selection
        @ReadWrite(bits: 3..<4)
        public var ccds: CCDS

        /// Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).
        @ReadWrite(bits: 8..<9)
        public var ois1: OIS1

        /// Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).
        @ReadWrite(bits: 9..<10)
        public var ois1n: OIS1N
    }

    /// TIM17 DMA/interrupt enable register
    @Register(bitWidth: 16)
    public struct DIER {
        /// Update interrupt enable
        @ReadWrite(bits: 0..<1)
        public var uie: UIE

        /// Capture/Compare 1 interrupt enable
        @ReadWrite(bits: 1..<2)
        public var cc1ie: CC1IE

        /// COM interrupt enable
        @ReadWrite(bits: 5..<6)
        public var comie: COMIE

        /// Break interrupt enable
        @ReadWrite(bits: 7..<8)
        public var bie: BIE

        /// Update DMA request enable
        @ReadWrite(bits: 8..<9)
        public var ude: UDE

        /// Capture/Compare 1 DMA request enable
        @ReadWrite(bits: 9..<10)
        public var cc1de: CC1DE
    }

    /// TIM17 status register
    @Register(bitWidth: 16)
    public struct SR {
        /// When CNT is reinitialized by software using the UG bit in TIMx_EGR register, if URS=0 and UDIS=0 in the TIMx_CR1 register.
        @ReadWrite(bits: 0..<1)
        public var uif: UIF

        /// If channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER).
        @ReadWrite(bits: 1..<2)
        public var cc1if: CC1IF

        /// This flag is set by hardware on a COM event (once the capture/compare control bits –CCxE, CCxNE, OCxM– have been updated). It is cleared by software.
        @ReadWrite(bits: 5..<6)
        public var comif: COMIF

        /// This flag is set by hardware as soon as the break input goes active. It can be cleared by software if the break input is not active.
        @ReadWrite(bits: 7..<8)
        public var bif: BIF

        /// This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to ‘0’.
        @ReadWrite(bits: 9..<10)
        public var cc1of: CC1OF
    }

    /// TIM17 event generation register
    @Register(bitWidth: 16)
    public struct EGR {
        /// This bit can be set by software, it is automatically cleared by hardware.
        @WriteOnly(bits: 0..<1)
        public var ug: UG

        /// The current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.
        @WriteOnly(bits: 1..<2)
        public var cc1g: CC1G

        /// Note: This bit acts only on channels that have a complementary output.
        @WriteOnly(bits: 5..<6)
        public var comg: COMG

        /// This bit is set by software in order to generate an event, it is automatically cleared by hardware.
        @WriteOnly(bits: 7..<8)
        public var bg: BG
    }

    /// TIM17 capture/compare mode register 1 [alternate]
    @Register(bitWidth: 32)
    public struct CCMR1_input {
        /// Note: CC1S bits are writable only when the channel is OFF (CC1E = ‘0’ in TIMx_CCER).
        @ReadWrite(bits: 0..<2)
        public var cc1s: CC1S

        /// The prescaler is reset as soon as CC1E=’0’ (TIMx_CCER register).
        @ReadWrite(bits: 2..<4)
        public var ic1psc: IC1PSC

        /// This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:
        @ReadWrite(bits: 4..<8)
        public var ic1f: IC1F
    }

    /// TIM17 capture/compare mode register 1 [alternate]
    @Register(bitWidth: 32)
    public struct CCMR1_output {
        /// Note: CC1S bits are writable only when the channel is OFF (CC1E = ‘0’ in TIMx_CCER).
        @ReadWrite(bits: 0..<2)
        public var cc1s: CC1S

        /// This bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the starting trigger.
        @ReadWrite(bits: 2..<3)
        public var oc1fe: OC1FE

        /// The PWM mode can be used without validating the preload register only in one pulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed.
        @ReadWrite(bits: 3..<4)
        public var oc1pe: OC1PE

        /// The OC1M[3] bit is not contiguous, located in bit 16.
        @ReadWrite(bits: 4..<7)
        public var oc1m1: OC1M1

        /// The OC1M[3] bit is not contiguous, located in bit 16.
        @ReadWrite(bits: 16..<17)
        public var oc1m2: OC1M2
    }

    /// TIM17 capture/compare enable register
    @Register(bitWidth: 16)
    public struct CCER {
        /// When CC1 channel is configured as output, the OC1 level depends on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits, regardless of the CC1E bits state. Refer to for details.
        @ReadWrite(bits: 0..<1)
        public var cc1e: CC1E

        /// On channels that have a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1P active bit takes the new value from the preloaded bit only when a Commutation event is generated.
        @ReadWrite(bits: 1..<2)
        public var cc1p: CC1P

        /// Capture/Compare 1 complementary output enable
        @ReadWrite(bits: 2..<3)
        public var cc1ne: CC1NE

        /// On channels that have a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NP active bit takes the new value from the preloaded bit only when a commutation event is generated.
        @ReadWrite(bits: 3..<4)
        public var cc1np: CC1NP
    }

    /// TIM17 counter
    @Register(bitWidth: 32)
    public struct CNT {
        /// Counter value
        @ReadWrite(bits: 0..<16)
        public var cnt_field: CNT_FIELD

        /// This bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in TIMx_CR1 is reset, bit 31 is reserved and read as 0.
        @ReadOnly(bits: 31..<32)
        public var uifcpy: UIFCPY
    }

    /// TIM17 prescaler
    @Register(bitWidth: 16)
    public struct PSC {
        /// PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in “reset mode”).
        @ReadWrite(bits: 0..<16)
        public var psc_field: PSC_FIELD
    }

    /// TIM17 auto-reload register
    @Register(bitWidth: 16)
    public struct ARR {
        /// The counter is blocked while the auto-reload value is null.
        @ReadWrite(bits: 0..<16)
        public var arr_field: ARR_FIELD
    }

    /// TIM17 repetition counter register
    @Register(bitWidth: 16)
    public struct RCR {
        /// It means in PWM mode (REP+1) corresponds to the number of PWM periods in edge-aligned mode.
        @ReadWrite(bits: 0..<8)
        public var rep: REP
    }

    /// TIM17 capture/compare register 1
    @Register(bitWidth: 16)
    public struct CCR1 {
        /// CCR1 is the counter value transferred by the last input capture 1 event (IC1).
        @ReadWrite(bits: 0..<16)
        public var ccr1_field: CCR1_FIELD
    }

    /// TIM17 break and dead-time register
    @Register(bitWidth: 32)
    public struct BDTR {
        /// Note: This bit-field can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).
        @ReadWrite(bits: 0..<8)
        public var dtg: DTG

        /// Note: The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register has been written, their content is frozen until the next reset.
        @ReadWrite(bits: 8..<10)
        public var lock: LOCK

        /// Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).
        @ReadWrite(bits: 10..<11)
        public var ossi: OSSI

        /// Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).
        @ReadWrite(bits: 11..<12)
        public var ossr: OSSR

        /// Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.
        @ReadWrite(bits: 12..<13)
        public var bke: BKE

        /// Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.
        @ReadWrite(bits: 13..<14)
        public var bkp: BKP

        /// Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
        @ReadWrite(bits: 14..<15)
        public var aoe: AOE

        /// enable register (TIM16_CCER)(TIMx_CCER)(x = 16 to 17) on page 1793).
        @ReadWrite(bits: 15..<16)
        public var moe: MOE

        /// This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
        @ReadWrite(bits: 16..<20)
        public var bkf: BKF

        /// Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.
        @ReadWrite(bits: 26..<27)
        public var bkdsrm: BKDSRM

        /// Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.
        @ReadWrite(bits: 28..<29)
        public var bkbid: BKBID
    }

    /// TIM17 DMA control register
    @Register(bitWidth: 16)
    public struct DCR {
        /// Example: Let us consider the following transfer: DBL = 7 transfers and DBA = TIMx_CR1. In this case the transfer is done to/from 7 registers starting from the TIMx_CR1 address.
        @ReadWrite(bits: 0..<5)
        public var dba: DBA

        /// ...
        @ReadWrite(bits: 8..<13)
        public var dbl: DBL
    }

    /// TIM17 DMA address for full transfer
    @Register(bitWidth: 16)
    public struct DMAR {
        /// where TIMx_CR1 address is the address of the control register 1, DBA is the DMA base address configured in TIMx_DCR register, DMA index is automatically controlled by the DMA transfer, and ranges from 0 to DBL (DBL configured in TIMx_DCR).
        @ReadWrite(bits: 0..<16)
        public var dmab: DMAB
    }

    /// TIM17 alternate function register 1
    @Register(bitWidth: 32)
    public struct AF1 {
        /// Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
        @ReadWrite(bits: 0..<1)
        public var bkine: BKINE

        /// Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
        @ReadWrite(bits: 9..<10)
        public var bkinp: BKINP
    }

    /// TIM17 input selection register
    @Register(bitWidth: 32)
    public struct TISEL {
        /// Others: Reserved
        @ReadWrite(bits: 0..<4)
        public var ti1sel: TI1SEL
    }
}

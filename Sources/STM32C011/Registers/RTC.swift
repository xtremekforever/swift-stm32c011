// Generated by svd2swift.

import MMIO

/// RTC register block
@RegisterBlock
public struct RTC: Sendable {
    /// RTC time register
    @RegisterBlock(offset: 0x0)
    public var tr: Register<TR>

    /// RTC date register
    @RegisterBlock(offset: 0x4)
    public var dr: Register<DR>

    /// RTC sub second register
    @RegisterBlock(offset: 0x8)
    public var ssr: Register<SSR>

    /// RTC initialization control and status register
    @RegisterBlock(offset: 0xc)
    public var icsr: Register<ICSR>

    /// RTC prescaler register
    @RegisterBlock(offset: 0x10)
    public var prer: Register<PRER>

    /// RTC control register
    @RegisterBlock(offset: 0x18)
    public var cr: Register<CR>

    /// RTC write protection register
    @RegisterBlock(offset: 0x24)
    public var wpr: Register<WPR>

    /// RTC calibration register
    @RegisterBlock(offset: 0x28)
    public var calr: Register<CALR>

    /// RTC shift control register
    @RegisterBlock(offset: 0x2c)
    public var shiftr: Register<SHIFTR>

    /// RTC timestamp time register
    @RegisterBlock(offset: 0x30)
    public var tstr: Register<TSTR>

    /// RTC timestamp date register
    @RegisterBlock(offset: 0x34)
    public var tsdr: Register<TSDR>

    /// RTC timestamp sub second register
    @RegisterBlock(offset: 0x38)
    public var tsssr: Register<TSSSR>

    /// RTC alarm A register
    @RegisterBlock(offset: 0x40)
    public var alrmar: Register<ALRMAR>

    /// RTC alarm A sub second register
    @RegisterBlock(offset: 0x44)
    public var alrmassr: Register<ALRMASSR>

    /// RTC status register
    @RegisterBlock(offset: 0x50)
    public var sr: Register<SR>

    /// RTC masked interrupt status register
    @RegisterBlock(offset: 0x54)
    public var misr: Register<MISR>

    /// RTC status clear register
    @RegisterBlock(offset: 0x5c)
    public var scr: Register<SCR>
}

extension RTC {
    /// RTC time register
    @Register(bitWidth: 32)
    public struct TR {
        /// Second units in BCD format
        @ReadWrite(bits: 0..<4)
        public var su: SU

        /// Second tens in BCD format
        @ReadWrite(bits: 4..<7)
        public var st: ST

        /// Minute units in BCD format
        @ReadWrite(bits: 8..<12)
        public var mnu: MNU

        /// Minute tens in BCD format
        @ReadWrite(bits: 12..<15)
        public var mnt: MNT

        /// Hour units in BCD format
        @ReadWrite(bits: 16..<20)
        public var hu: HU

        /// Hour tens in BCD format
        @ReadWrite(bits: 20..<22)
        public var ht: HT

        /// AM/PM notation
        @ReadWrite(bits: 22..<23)
        public var pm: PM
    }

    /// RTC date register
    @Register(bitWidth: 32)
    public struct DR {
        /// Date units in BCD format
        @ReadWrite(bits: 0..<4)
        public var du: DU

        /// Date tens in BCD format
        @ReadWrite(bits: 4..<6)
        public var dt: DT

        /// Month units in BCD format
        @ReadWrite(bits: 8..<12)
        public var mu: MU

        /// Month tens in BCD format
        @ReadWrite(bits: 12..<13)
        public var mt: MT

        /// ...
        @ReadWrite(bits: 13..<16)
        public var wdu: WDU

        /// Year units in BCD format
        @ReadWrite(bits: 16..<20)
        public var yu: YU

        /// Year tens in BCD format
        @ReadWrite(bits: 20..<24)
        public var yt: YT
    }

    /// RTC sub second register
    @Register(bitWidth: 32)
    public struct SSR {
        /// Note: SS can be larger than PREDIV_S only after a shift operation. In that case, the correct time/date is one second less than as indicated by RTC_TR/RTC_DR.
        @ReadOnly(bits: 0..<16)
        public var ss: SS
    }

    /// RTC initialization control and status register
    @Register(bitWidth: 32)
    public struct ICSR {
        /// It is cleared by hardware in initialization mode.
        @ReadOnly(bits: 0..<1)
        public var alrawf: ALRAWF

        /// This flag is set by hardware as soon as a shift operation is initiated by a write to the RTC_SHIFTR register. It is cleared by hardware when the corresponding shift operation has been executed. Writing to the SHPF bit has no effect.
        @ReadOnly(bits: 3..<4)
        public var shpf: SHPF

        /// This bit is set by hardware when the calendar year field is different from 0 (Power-on reset state).
        @ReadOnly(bits: 4..<5)
        public var inits: INITS

        /// It is cleared either by software or by hardware in initialization mode.
        @ReadWrite(bits: 5..<6)
        public var rsf: RSF

        /// When this bit is set to 1, the RTC is in initialization state, and the time, date and prescaler registers can be updated.
        @ReadOnly(bits: 6..<7)
        public var initf: INITF

        /// Initialization mode
        @ReadWrite(bits: 7..<8)
        public var `init`: INIT

        /// The RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0. Refer to .
        @ReadOnly(bits: 16..<17)
        public var recalpf: RECALPF
    }

    /// RTC prescaler register
    @Register(bitWidth: 32)
    public struct PRER {
        /// ck_spre frequency = ck_apre frequency/(PREDIV_S+1)
        @ReadWrite(bits: 0..<15)
        public var prediv_s: PREDIV_S

        /// ck_apre frequency = RTCCLK frequency/(PREDIV_A+1)
        @ReadWrite(bits: 16..<23)
        public var prediv_a: PREDIV_A
    }

    /// RTC control register
    @Register(bitWidth: 32)
    public struct CR {
        /// TSE must be reset when TSEDGE is changed to avoid unwanted TSF setting.
        @ReadWrite(bits: 3..<4)
        public var tsedge: TSEDGE

        /// Note: PREDIV_S must be 0x00FF.
        @ReadWrite(bits: 4..<5)
        public var refckon: REFCKON

        /// Note: If the frequency of the APB1 clock is less than seven times the frequency of RTCCLK, BYPSHAD must be set to 1.
        @ReadWrite(bits: 5..<6)
        public var bypshad: BYPSHAD

        /// Hour format
        @ReadWrite(bits: 6..<7)
        public var fmt: FMT

        /// Alarm A enable
        @ReadWrite(bits: 8..<9)
        public var alrae: ALRAE

        /// timestamp enable
        @ReadWrite(bits: 11..<12)
        public var tse: TSE

        /// Alarm A interrupt enable
        @ReadWrite(bits: 12..<13)
        public var alraie: ALRAIE

        /// Timestamp interrupt enable
        @ReadWrite(bits: 15..<16)
        public var tsie: TSIE

        /// When this bit is set outside initialization mode, 1 hour is added to the calendar time. This bit is always read as 0.
        @WriteOnly(bits: 16..<17)
        public var add1h: ADD1H

        /// Setting this bit has no effect when current hour is 0.
        @WriteOnly(bits: 17..<18)
        public var sub1h: SUB1H

        /// This bit can be written by the user to memorize whether the daylight saving time change has been performed or not.
        @ReadWrite(bits: 18..<19)
        public var bkp: BKP

        /// These frequencies are valid for RTCCLK at 32.768 kHz and prescalers at their default values (PREDIV_A = 127 and PREDIV_S = 255). Refer to .
        @ReadWrite(bits: 19..<20)
        public var cosel: COSEL

        /// This bit is used to configure the polarity of TAMPALRM output.
        @ReadWrite(bits: 20..<21)
        public var pol: POL

        /// These bits are used to select the flag to be routed to TAMPALRM output.
        @ReadWrite(bits: 21..<23)
        public var osel: OSEL

        /// This bit enables the CALIB output
        @ReadWrite(bits: 23..<24)
        public var coe: COE

        /// TAMPALRM pull-up enable
        @ReadWrite(bits: 29..<30)
        public var tampalrm_pu: TAMPALRM_PU

        /// TAMPALRM output type
        @ReadWrite(bits: 30..<31)
        public var tampalrm_type: TAMPALRM_TYPE

        /// If (OSELâ‰  00 or TAMPOE = 1) and COE = 1: CALIB is output on RTC_OUT2 and TAMPALRM is output on RTC_OUT1.
        @ReadWrite(bits: 31..<32)
        public var out2en: OUT2EN
    }

    /// RTC write protection register
    @Register(bitWidth: 32)
    public struct WPR {
        /// Refer to for a description of how to unlock RTC register write protection.
        @WriteOnly(bits: 0..<8)
        public var key: KEY
    }

    /// RTC calibration register
    @Register(bitWidth: 32)
    public struct CALR {
        /// To increase the frequency of the calendar, this feature should be used in conjunction with CALP. See .
        @ReadWrite(bits: 0..<9)
        public var calm: CALM

        /// Note: CALM[0] is stuck at 0 when CALW16 = 1. Refer to calibration.
        @ReadWrite(bits: 13..<14)
        public var calw16: CALW16

        /// Note: CALM[1:0] are stuck at 00 when CALW8 = 1. Refer to digital calibration.
        @ReadWrite(bits: 14..<15)
        public var calw8: CALW8

        /// Refer to .
        @ReadWrite(bits: 15..<16)
        public var calp: CALP
    }

    /// RTC shift control register
    @Register(bitWidth: 32)
    public struct SHIFTR {
        /// Note: Writing to SUBFS causes RSF to be cleared. Software can then wait until RSF = 1 to be sure that the shadow registers have been updated with the shifted time.
        @WriteOnly(bits: 0..<15)
        public var subfs: SUBFS

        /// This function is intended to be used with SUBFS (see description below) in order to effectively add a fraction of a second to the clock in an atomic operation.
        @WriteOnly(bits: 31..<32)
        public var add1s: ADD1S
    }

    /// RTC timestamp time register
    @Register(bitWidth: 32)
    public struct TSTR {
        /// Second units in BCD format.
        @ReadOnly(bits: 0..<4)
        public var su: SU

        /// Second tens in BCD format.
        @ReadOnly(bits: 4..<7)
        public var st: ST

        /// Minute units in BCD format.
        @ReadOnly(bits: 8..<12)
        public var mnu: MNU

        /// Minute tens in BCD format.
        @ReadOnly(bits: 12..<15)
        public var mnt: MNT

        /// Hour units in BCD format.
        @ReadOnly(bits: 16..<20)
        public var hu: HU

        /// Hour tens in BCD format.
        @ReadOnly(bits: 20..<22)
        public var ht: HT

        /// AM/PM notation
        @ReadOnly(bits: 22..<23)
        public var pm: PM
    }

    /// RTC timestamp date register
    @Register(bitWidth: 32)
    public struct TSDR {
        /// Date units in BCD format
        @ReadOnly(bits: 0..<4)
        public var du: DU

        /// Date tens in BCD format
        @ReadOnly(bits: 4..<6)
        public var dt: DT

        /// Month units in BCD format
        @ReadOnly(bits: 8..<12)
        public var mu: MU

        /// Month tens in BCD format
        @ReadOnly(bits: 12..<13)
        public var mt: MT

        /// Week day units
        @ReadOnly(bits: 13..<16)
        public var wdu: WDU
    }

    /// RTC timestamp sub second register
    @Register(bitWidth: 32)
    public struct TSSSR {
        /// SS[15:0] is the value of the synchronous prescaler counter when the timestamp event occurred.
        @ReadOnly(bits: 0..<16)
        public var ss: SS
    }

    /// RTC alarm A register
    @Register(bitWidth: 32)
    public struct ALRMAR {
        /// Second units in BCD format.
        @ReadWrite(bits: 0..<4)
        public var su: SU

        /// Second tens in BCD format.
        @ReadWrite(bits: 4..<7)
        public var st: ST

        /// Alarm A seconds mask
        @ReadWrite(bits: 7..<8)
        public var msk1: MSK1

        /// Minute units in BCD format
        @ReadWrite(bits: 8..<12)
        public var mnu: MNU

        /// Minute tens in BCD format
        @ReadWrite(bits: 12..<15)
        public var mnt: MNT

        /// Alarm A minutes mask
        @ReadWrite(bits: 15..<16)
        public var msk2: MSK2

        /// Hour units in BCD format
        @ReadWrite(bits: 16..<20)
        public var hu: HU

        /// Hour tens in BCD format
        @ReadWrite(bits: 20..<22)
        public var ht: HT

        /// AM/PM notation
        @ReadWrite(bits: 22..<23)
        public var pm: PM

        /// Alarm A hours mask
        @ReadWrite(bits: 23..<24)
        public var msk3: MSK3

        /// Date units or day in BCD format
        @ReadWrite(bits: 24..<28)
        public var du: DU

        /// Date tens in BCD format
        @ReadWrite(bits: 28..<30)
        public var dt: DT

        /// Week day selection
        @ReadWrite(bits: 30..<31)
        public var wdsel: WDSEL

        /// Alarm A date mask
        @ReadWrite(bits: 31..<32)
        public var msk4: MSK4
    }

    /// RTC alarm A sub second register
    @Register(bitWidth: 32)
    public struct ALRMASSR {
        /// This value is compared with the contents of the synchronous prescaler counter to determine if alarm A is to be activated. Only bits 0 up MASKSS-1 are compared.
        @ReadWrite(bits: 0..<15)
        public var ss: SS

        /// Note: The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation.
        @ReadWrite(bits: 24..<28)
        public var maskss: MASKSS
    }

    /// RTC status register
    @Register(bitWidth: 32)
    public struct SR {
        /// This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the alarm A register (RTC_ALRMAR).
        @ReadOnly(bits: 0..<1)
        public var alraf: ALRAF

        /// This flag is set by hardware when a timestamp event occurs.
        @ReadOnly(bits: 3..<4)
        public var tsf: TSF

        /// It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared.
        @ReadOnly(bits: 4..<5)
        public var tsovf: TSOVF
    }

    /// RTC masked interrupt status register
    @Register(bitWidth: 32)
    public struct MISR {
        /// This flag is set by hardware when the alarm A interrupt occurs.
        @ReadOnly(bits: 0..<1)
        public var alramf: ALRAMF

        /// This flag is set by hardware when a timestamp interrupt occurs.
        @ReadOnly(bits: 3..<4)
        public var tsmf: TSMF

        /// It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared.
        @ReadOnly(bits: 4..<5)
        public var tsovmf: TSOVMF
    }

    /// RTC status clear register
    @Register(bitWidth: 32)
    public struct SCR {
        /// Writing 1 in this bit clears the ALRAF bit in the RTC_SR register.
        @WriteOnly(bits: 0..<1)
        public var calraf: CALRAF

        /// Writing 1 in this bit clears the TSOVF bit in the RTC_SR register.
        @WriteOnly(bits: 3..<4)
        public var ctsf: CTSF

        /// It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a timestamp event occurs immediately before the TSF bit is cleared.
        @WriteOnly(bits: 4..<5)
        public var ctsovf: CTSOVF
    }
}

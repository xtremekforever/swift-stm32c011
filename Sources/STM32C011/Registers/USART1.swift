// Generated by svd2swift.

import MMIO

/// USART register block
@RegisterBlock
public struct USART1: Sendable {
    /// USART control register 1 [alternate]
    @RegisterBlock(offset: 0x0)
    public var cr1_enabled: Register<CR1_enabled>

    /// USART control register 1 [alternate]
    @RegisterBlock(offset: 0x0)
    public var cr1_disabled: Register<CR1_disabled>

    /// USART control register 2
    @RegisterBlock(offset: 0x4)
    public var cr2: Register<CR2>

    /// USART control register 3
    @RegisterBlock(offset: 0x8)
    public var cr3: Register<CR3>

    /// USART baud rate register
    @RegisterBlock(offset: 0xc)
    public var brr: Register<BRR>

    /// USART guard time and prescaler register
    @RegisterBlock(offset: 0x10)
    public var gtpr: Register<GTPR>

    /// USART receiver timeout register
    @RegisterBlock(offset: 0x14)
    public var rtor: Register<RTOR>

    /// USART request register
    @RegisterBlock(offset: 0x18)
    public var rqr: Register<RQR>

    /// USART interrupt and status register [alternate]
    @RegisterBlock(offset: 0x1c)
    public var isr_enabled: Register<ISR_enabled>

    /// USART interrupt and status register [alternate]
    @RegisterBlock(offset: 0x1c)
    public var isr_disabled: Register<ISR_disabled>

    /// USART interrupt flag clear register
    @RegisterBlock(offset: 0x20)
    public var icr: Register<ICR>

    /// USART receive data register
    @RegisterBlock(offset: 0x24)
    public var rdr: Register<RDR>

    /// USART transmit data register
    @RegisterBlock(offset: 0x28)
    public var tdr: Register<TDR>

    /// USART prescaler register
    @RegisterBlock(offset: 0x2c)
    public var presc: Register<PRESC>
}

extension USART1 {
    /// USART control register 1 [alternate]
    @Register(bitWidth: 32)
    public struct CR1_enabled {
        /// In Smartcard mode, (SCEN = 1), the CK is always available when CLKEN = 1, regardless of the UE bit value.
        @ReadWrite(bits: 0..<1)
        public var ue: UE

        /// If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page 1985.
        @ReadWrite(bits: 1..<2)
        public var uesm: UESM

        /// This bit enables the receiver. It is set and cleared by software.
        @ReadWrite(bits: 2..<3)
        public var re: RE

        /// In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts.
        @ReadWrite(bits: 3..<4)
        public var te: TE

        /// This bit is set and cleared by software.
        @ReadWrite(bits: 4..<5)
        public var idleie: IDLEIE

        /// This bit is set and cleared by software.
        @ReadWrite(bits: 5..<6)
        public var rxfneie: RXFNEIE

        /// This bit is set and cleared by software.
        @ReadWrite(bits: 6..<7)
        public var tcie: TCIE

        /// This bit is set and cleared by software.
        @ReadWrite(bits: 7..<8)
        public var txfnfie: TXFNFIE

        /// This bit is set and cleared by software.
        @ReadWrite(bits: 8..<9)
        public var peie: PEIE

        /// This bitfield can only be written when the USART is disabled (UE = 0).
        @ReadWrite(bits: 9..<10)
        public var ps: PS

        /// This bitfield can only be written when the USART is disabled (UE = 0).
        @ReadWrite(bits: 10..<11)
        public var pce: PCE

        /// This bitfield can only be written when the USART is disabled (UE = 0).
        @ReadWrite(bits: 11..<12)
        public var wake: WAKE

        /// This bit can only be written when the USART is disabled (UE = 0).
        @ReadWrite(bits: 12..<13)
        public var m0: M0

        /// This bit enables the USART Mute mode function. When set, the USART can switch between active and Mute mode, as defined by the WAKE bit. It is set and cleared by software.
        @ReadWrite(bits: 13..<14)
        public var mme: MME

        /// This bit is set and cleared by software.
        @ReadWrite(bits: 14..<15)
        public var cmie: CMIE

        /// Note: In LIN, IrDA and Smartcard modes, this bit must be kept cleared.
        @ReadWrite(bits: 15..<16)
        public var over8: OVER8

        /// Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .
        @ReadWrite(bits: 16..<21)
        public var dedt: DEDT

        /// Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .
        @ReadWrite(bits: 21..<26)
        public var deat: DEAT

        /// Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. .
        @ReadWrite(bits: 26..<27)
        public var rtoie: RTOIE

        /// Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .
        @ReadWrite(bits: 27..<28)
        public var eobie: EOBIE

        /// Note: In 7-bits data length mode, the Smartcard mode, LIN master mode and Auto baud rate (0x7F and 0x55 frames detection) are not supported.
        @ReadWrite(bits: 28..<29)
        public var m1: M1

        /// Note: FIFO mode can be used on standard UART communication, in SPI master/slave mode and in Smartcard modes only. It must not be enabled in IrDA and LIN modes.
        @ReadWrite(bits: 29..<30)
        public var fifoen: FIFOEN

        /// This bit is set and cleared by software.
        @ReadWrite(bits: 30..<31)
        public var txfeie: TXFEIE

        /// This bit is set and cleared by software.
        @ReadWrite(bits: 31..<32)
        public var rxffie: RXFFIE
    }

    /// USART control register 1 [alternate]
    @Register(bitWidth: 32)
    public struct CR1_disabled {
        /// In Smartcard mode, (SCEN = 1), the CK pin is always available when CLKEN = 1, regardless of the UE bit value.
        @ReadWrite(bits: 0..<1)
        public var ue: UE

        /// If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page 1985.
        @ReadWrite(bits: 1..<2)
        public var uesm: UESM

        /// This bit enables the receiver. It is set and cleared by software.
        @ReadWrite(bits: 2..<3)
        public var re: RE

        /// In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission starts.
        @ReadWrite(bits: 3..<4)
        public var te: TE

        /// This bit is set and cleared by software.
        @ReadWrite(bits: 4..<5)
        public var idleie: IDLEIE

        /// This bit is set and cleared by software.
        @ReadWrite(bits: 5..<6)
        public var rxneie: RXNEIE

        /// This bit is set and cleared by software.
        @ReadWrite(bits: 6..<7)
        public var tcie: TCIE

        /// This bit is set and cleared by software.
        @ReadWrite(bits: 7..<8)
        public var txeie: TXEIE

        /// This bit is set and cleared by software.
        @ReadWrite(bits: 8..<9)
        public var peie: PEIE

        /// This bitfield can only be written when the USART is disabled (UE = 0).
        @ReadWrite(bits: 9..<10)
        public var ps: PS

        /// This bitfield can only be written when the USART is disabled (UE = 0).
        @ReadWrite(bits: 10..<11)
        public var pce: PCE

        /// This bitfield can only be written when the USART is disabled (UE = 0).
        @ReadWrite(bits: 11..<12)
        public var wake: WAKE

        /// This bit can only be written when the USART is disabled (UE = 0).
        @ReadWrite(bits: 12..<13)
        public var m0: M0

        /// This bit enables the USART Mute mode function. When set, the USART can switch between active and Mute mode, as defined by the WAKE bit. It is set and cleared by software.
        @ReadWrite(bits: 13..<14)
        public var mme: MME

        /// This bit is set and cleared by software.
        @ReadWrite(bits: 14..<15)
        public var cmie: CMIE

        /// Note: In LIN, IrDA and Smartcard modes, this bit must be kept cleared.
        @ReadWrite(bits: 15..<16)
        public var over8: OVER8

        /// Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .
        @ReadWrite(bits: 16..<21)
        public var dedt: DEDT

        /// Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .
        @ReadWrite(bits: 21..<26)
        public var deat: DEAT

        /// Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. .
        @ReadWrite(bits: 26..<27)
        public var rtoie: RTOIE

        /// Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .
        @ReadWrite(bits: 27..<28)
        public var eobie: EOBIE

        /// Note: In 7-bits data length mode, the Smartcard mode, LIN master mode and Auto baud rate (0x7F and 0x55 frames detection) are not supported.
        @ReadWrite(bits: 28..<29)
        public var m1: M1

        /// Note: FIFO mode can be used on standard UART communication, in SPI master/slave mode and in Smartcard modes only. It must not be enabled in IrDA and LIN modes.
        @ReadWrite(bits: 29..<30)
        public var fifoen: FIFOEN
    }

    /// USART control register 2
    @Register(bitWidth: 32)
    public struct CR2 {
        /// Note: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value. Refer to .
        @ReadWrite(bits: 0..<1)
        public var slven: SLVEN

        /// Note: When SPI slave mode is not supported, this bit is reserved and must be kept at reset value. Refer to .
        @ReadWrite(bits: 3..<4)
        public var dis_nss: DIS_NSS

        /// Note: In 7-bit and 9-bit data modes, the address detection is done on 6-bit and 8-bit address (ADD[5:0] and ADD[7:0]) respectively.
        @ReadWrite(bits: 4..<5)
        public var addm7: ADDM7

        /// Note: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to .
        @ReadWrite(bits: 5..<6)
        public var lbdl: LBDL

        /// Note: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to .
        @ReadWrite(bits: 6..<7)
        public var lbdie: LBDIE

        /// Note: If synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to .
        @ReadWrite(bits: 8..<9)
        public var lbcl: LBCL

        /// Note: If synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to .
        @ReadWrite(bits: 9..<10)
        public var cpha: CPHA

        /// Note: If synchronous mode is not supported, this bit is reserved and must be kept at reset value. Refer to .
        @ReadWrite(bits: 10..<11)
        public var cpol: CPOL

        /// UE = 1
        @ReadWrite(bits: 11..<12)
        public var clken: CLKEN

        /// This bitfield can only be written when the USART is disabled (UE = 0).
        @ReadWrite(bits: 12..<14)
        public var stop: STOP

        /// Note: If the USART does not support LIN mode, this bit is reserved and must be kept at reset value. Refer to .
        @ReadWrite(bits: 14..<15)
        public var linen: LINEN

        /// This bitfield can only be written when the USART is disabled (UE = 0).
        @ReadWrite(bits: 15..<16)
        public var swap: SWAP

        /// This bitfield can only be written when the USART is disabled (UE = 0).
        @ReadWrite(bits: 16..<17)
        public var rxinv: RXINV

        /// This bitfield can only be written when the USART is disabled (UE = 0).
        @ReadWrite(bits: 17..<18)
        public var txinv: TXINV

        /// This bitfield can only be written when the USART is disabled (UE = 0).
        @ReadWrite(bits: 18..<19)
        public var datainv: DATAINV

        /// This bitfield can only be written when the USART is disabled (UE = 0).
        @ReadWrite(bits: 19..<20)
        public var msbfirst: MSBFIRST

        /// Note: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to .
        @ReadWrite(bits: 20..<21)
        public var abren: ABREN

        /// If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to .
        @ReadWrite(bits: 21..<23)
        public var abrmod: ABRMOD

        /// Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Refer to .
        @ReadWrite(bits: 23..<24)
        public var rtoen: RTOEN

        /// These bits can only be written when the reception is disabled (RE = 0) or when the USART is disabled (UE = 0).
        @ReadWrite(bits: 24..<32)
        public var add: ADD
    }

    /// USART control register 3
    @Register(bitWidth: 32)
    public struct CR3 {
        /// Error Interrupt Enable Bit is required to enable interrupt generation in case of a framing error, overrun error noise flag or SPI slave underrun error (FE = 1 or ORE = 1 or NE = 1 or UDR = 1 in the USART_ISR register).
        @ReadWrite(bits: 0..<1)
        public var eie: EIE

        /// Note: If IrDA mode is not supported, this bit is reserved and must be kept at reset value. Refer to .
        @ReadWrite(bits: 1..<2)
        public var iren: IREN

        /// Note: If IrDA mode is not supported, this bit is reserved and must be kept at reset value. Refer to .
        @ReadWrite(bits: 2..<3)
        public var irlp: IRLP

        /// This bit can only be written when the USART is disabled (UE = 0).
        @ReadWrite(bits: 3..<4)
        public var hdsel: HDSEL

        /// Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .
        @ReadWrite(bits: 4..<5)
        public var nack: NACK

        /// Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .
        @ReadWrite(bits: 5..<6)
        public var scen: SCEN

        /// This bit is set/reset by software
        @ReadWrite(bits: 6..<7)
        public var dmar: DMAR

        /// This bit is set/reset by software
        @ReadWrite(bits: 7..<8)
        public var dmat: DMAT

        /// Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to .
        @ReadWrite(bits: 8..<9)
        public var rtse: RTSE

        /// Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to .
        @ReadWrite(bits: 9..<10)
        public var ctse: CTSE

        /// Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to .
        @ReadWrite(bits: 10..<11)
        public var ctsie: CTSIE

        /// This bit can only be written when the USART is disabled (UE = 0).
        @ReadWrite(bits: 11..<12)
        public var onebit: ONEBIT

        /// Note: This control bit enables checking the communication flow w/o reading the data
        @ReadWrite(bits: 12..<13)
        public var ovrdis: OVRDIS

        /// Note: The reception errors are: parity error, framing error or noise error.
        @ReadWrite(bits: 13..<14)
        public var ddre: DDRE

        /// Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. .
        @ReadWrite(bits: 14..<15)
        public var dem: DEM

        /// Note: If the Driver Enable feature is not supported, this bit is reserved and must be kept at reset value. Refer to .
        @ReadWrite(bits: 15..<16)
        public var dep: DEP

        /// Note: If Smartcard mode is not supported, this bit is reserved and must be kept at reset value. Refer to .
        @ReadWrite(bits: 17..<20)
        public var scarcnt: SCARCNT

        /// If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page 1985.
        @ReadWrite(bits: 20..<22)
        public var wus: WUS

        /// If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page 1985.
        @ReadWrite(bits: 22..<23)
        public var wufie: WUFIE

        /// This bit is set and cleared by software.
        @ReadWrite(bits: 23..<24)
        public var txftie: TXFTIE

        /// Note: If the USART does not support the Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .
        @ReadWrite(bits: 24..<25)
        public var tcbgtie: TCBGTIE

        /// Remaining combinations: Reserved
        @ReadWrite(bits: 25..<28)
        public var rxftcfg: RXFTCFG

        /// This bit is set and cleared by software.
        @ReadWrite(bits: 28..<29)
        public var rxftie: RXFTIE

        /// Remaining combinations: Reserved
        @ReadWrite(bits: 29..<32)
        public var txftcfg: TXFTCFG
    }

    /// USART baud rate register
    @Register(bitWidth: 32)
    public struct BRR {
        /// BRR[3] must be kept cleared.
        @ReadWrite(bits: 0..<16)
        public var brr_field: BRR_FIELD
    }

    /// USART guard time and prescaler register
    @Register(bitWidth: 32)
    public struct GTPR {
        /// This bitfield is reserved and forced by hardware to ‘0’ when the Smartcard and IrDA modes are not supported. Refer to .
        @ReadWrite(bits: 0..<8)
        public var psc: PSC

        /// Note: If Smartcard mode is not supported, this bit is reserved and must be kept at reset value. Refer to .
        @ReadWrite(bits: 8..<16)
        public var gt: GT
    }

    /// USART receiver timeout register
    @Register(bitWidth: 32)
    public struct RTOR {
        /// Note: This value must only be programmed once per received character.
        @ReadWrite(bits: 0..<24)
        public var rto: RTO

        /// Note: This value can be programmed after the start of the block reception (using the data from the LEN character in the Prologue Field). It must be programmed only once per received block.
        @ReadWrite(bits: 24..<32)
        public var blen: BLEN
    }

    /// USART request register
    @Register(bitWidth: 32)
    public struct RQR {
        /// Note: If the USART does not support the auto baud rate feature, this bit is reserved and must be kept at reset value. Refer to .
        @WriteOnly(bits: 0..<1)
        public var abrrq: ABRRQ

        /// Note: When the application needs to send the break character following all previously inserted data, including the ones not yet transmitted, the software should wait for the TXE flag assertion before setting the SBKRQ bit.
        @WriteOnly(bits: 1..<2)
        public var sbkrq: SBKRQ

        /// Writing 1 to this bit puts the USART in Mute mode and resets the RWU flag.
        @WriteOnly(bits: 2..<3)
        public var mmrq: MMRQ

        /// This enables to discard the received data without reading them, and avoid an overrun condition.
        @WriteOnly(bits: 3..<4)
        public var rxfrq: RXFRQ

        /// Note: In FIFO mode, the TXFNF flag is reset during the flush request until TxFIFO is empty in order to ensure that no data are written in the data register.
        @WriteOnly(bits: 4..<5)
        public var txfrq: TXFRQ
    }

    /// USART interrupt and status register [alternate]
    @Register(bitWidth: 32)
    public struct ISR_enabled {
        /// Note: This error is associated with the character in the USART_RDR.
        @ReadOnly(bits: 0..<1)
        public var pe: PE

        /// Note: This error is associated with the character in the USART_RDR.
        @ReadOnly(bits: 1..<2)
        public var fe: FE

        /// This error is associated with the character in the USART_RDR.
        @ReadOnly(bits: 2..<3)
        public var ne: NE

        /// This bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the USART_CR3 register.
        @ReadOnly(bits: 3..<4)
        public var ore: ORE

        /// If Mute mode is enabled (MME = 1), IDLE is set if the USART is not mute (RWU = 0), whatever the Mute mode selected by the WAKE bit. If RWU = 1, IDLE is not set.
        @ReadOnly(bits: 4..<5)
        public var idle: IDLE

        /// An interrupt is generated if RXFNEIE = 1 in the USART_CR1 register.
        @ReadOnly(bits: 5..<6)
        public var rxfne: RXFNE

        /// Note: If TE bit is reset and no transmission is on going, the TC bit is immediately set.
        @ReadOnly(bits: 6..<7)
        public var tc: TC

        /// This bit is used during single buffer transmission.
        @ReadOnly(bits: 7..<8)
        public var txfnf: TXFNF

        /// Note: If the USART does not support LIN mode, this bit is reserved and kept at reset value. Refer to .
        @ReadOnly(bits: 8..<9)
        public var lbdf: LBDF

        /// Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.
        @ReadOnly(bits: 9..<10)
        public var ctsif: CTSIF

        /// Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.
        @ReadOnly(bits: 10..<11)
        public var cts: CTS

        /// If the USART does not support the Receiver timeout feature, this bit is reserved and kept at reset value.
        @ReadOnly(bits: 11..<12)
        public var rtof: RTOF

        /// Note: If Smartcard mode is not supported, this bit is reserved and kept at reset value. Refer to .
        @ReadOnly(bits: 12..<13)
        public var eobf: EOBF

        /// Note: If the USART does not support the SPI slave mode, this bit is reserved and kept at reset value. Refer to .
        @ReadOnly(bits: 13..<14)
        public var udr: UDR

        /// Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.
        @ReadOnly(bits: 14..<15)
        public var abre: ABRE

        /// Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.
        @ReadOnly(bits: 15..<16)
        public var abrf: ABRF

        /// This bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not).
        @ReadOnly(bits: 16..<17)
        public var busy: BUSY

        /// An interrupt is generated if CMIE = 1in the USART_CR1 register.
        @ReadOnly(bits: 17..<18)
        public var cmf: CMF

        /// This bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.
        @ReadOnly(bits: 18..<19)
        public var sbkf: SBKF

        /// Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .
        @ReadOnly(bits: 19..<20)
        public var rwu: RWU

        /// If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .
        @ReadOnly(bits: 20..<21)
        public var wuf: WUF

        /// It can be used when an idle frame request is generated by writing TE = 0, followed by TE = 1 in the USART_CR1 register, in order to respect the TE = 0 minimum period.
        @ReadOnly(bits: 21..<22)
        public var teack: TEACK

        /// Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .
        @ReadOnly(bits: 22..<23)
        public var reack: REACK

        /// An interrupt is generated if the TXFEIE bit = 1 (bit 30) in the USART_CR1 register.
        @ReadOnly(bits: 23..<24)
        public var txfe: TXFE

        /// An interrupt is generated if the RXFFIE bit = 1 in the USART_CR1 register.
        @ReadOnly(bits: 24..<25)
        public var rxff: RXFF

        /// Note: If the USART does not support the Smartcard mode, this bit is reserved and kept at reset value. If the USART supports the Smartcard mode and the Smartcard mode is enabled, the TCBGT reset value is ‘1’. Refer to on page 1985.
        @ReadOnly(bits: 25..<26)
        public var tcbgt: TCBGT

        /// Note: When the RXFTCFG threshold is configured to ‘101’, RXFT flag is set if 16 data are available i.e. 15 data in the RXFIFO and 1 data in the USART_RDR. Consequently, the 17th received data does not cause an overrun error. The overrun error occurs after receiving the 18th data.
        @ReadOnly(bits: 26..<27)
        public var rxft: RXFT

        /// This bit is set by hardware when the TXFIFO reaches the threshold programmed in TXFTCFG of USART_CR3 register i.e. the TXFIFO contains TXFTCFG empty locations. An interrupt is generated if the TXFTIE bit = 1 (bit 31) in the USART_CR3 register.
        @ReadOnly(bits: 27..<28)
        public var txft: TXFT
    }

    /// USART interrupt and status register [alternate]
    @Register(bitWidth: 32)
    public struct ISR_disabled {
        /// An interrupt is generated if PEIE = 1 in the USART_CR1 register.
        @ReadOnly(bits: 0..<1)
        public var pe: PE

        /// An interrupt is generated if EIE = 1 in the USART_CR1 register.
        @ReadOnly(bits: 1..<2)
        public var fe: FE

        /// When the line is noise-free, the NE flag can be disabled by programming the ONEBIT bit to 1 to increase the USART tolerance to deviations (Refer to Tolerance of the USART receiver to clock deviation on page 2012).
        @ReadOnly(bits: 2..<3)
        public var ne: NE

        /// This bit is permanently forced to 0 (no overrun detection) when the bit OVRDIS is set in the USART_CR3 register.
        @ReadOnly(bits: 3..<4)
        public var ore: ORE

        /// If Mute mode is enabled (MME = 1), IDLE is set if the USART is not mute (RWU = 0), whatever the Mute mode selected by the WAKE bit. If RWU = 1, IDLE is not set.
        @ReadOnly(bits: 4..<5)
        public var idle: IDLE

        /// An interrupt is generated if RXNEIE = 1 in the USART_CR1 register.
        @ReadOnly(bits: 5..<6)
        public var rxne: RXNE

        /// Note: If TE bit is reset and no transmission is on going, the TC bit is set immediately.
        @ReadOnly(bits: 6..<7)
        public var tc: TC

        /// An interrupt is generated if the TXEIE bit = 1 in the USART_CR1 register.
        @ReadOnly(bits: 7..<8)
        public var txe: TXE

        /// Note: If the USART does not support LIN mode, this bit is reserved and kept at reset value. Refer to .
        @ReadOnly(bits: 8..<9)
        public var lbdf: LBDF

        /// Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.
        @ReadOnly(bits: 9..<10)
        public var ctsif: CTSIF

        /// Note: If the hardware flow control feature is not supported, this bit is reserved and kept at reset value.
        @ReadOnly(bits: 10..<11)
        public var cts: CTS

        /// If the USART does not support the Receiver timeout feature, this bit is reserved and kept at reset value.
        @ReadOnly(bits: 11..<12)
        public var rtof: RTOF

        /// Note: If Smartcard mode is not supported, this bit is reserved and kept at reset value. Refer to .
        @ReadOnly(bits: 12..<13)
        public var eobf: EOBF

        /// Note: If the USART does not support the SPI slave mode, this bit is reserved and kept at reset value. Refer to .
        @ReadOnly(bits: 13..<14)
        public var udr: UDR

        /// Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.
        @ReadOnly(bits: 14..<15)
        public var abre: ABRE

        /// Note: If the USART does not support the auto baud rate feature, this bit is reserved and kept at reset value.
        @ReadOnly(bits: 15..<16)
        public var abrf: ABRF

        /// This bit is set and reset by hardware. It is active when a communication is ongoing on the RX line (successful start bit detected). It is reset at the end of the reception (successful or not).
        @ReadOnly(bits: 16..<17)
        public var busy: BUSY

        /// An interrupt is generated if CMIE = 1in the USART_CR1 register.
        @ReadOnly(bits: 17..<18)
        public var cmf: CMF

        /// This bit indicates that a send break character was requested. It is set by software, by writing 1 to the SBKRQ bit in the USART_CR3 register. It is automatically reset by hardware during the stop bit of break transmission.
        @ReadOnly(bits: 18..<19)
        public var sbkf: SBKF

        /// Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .
        @ReadOnly(bits: 19..<20)
        public var rwu: RWU

        /// If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .
        @ReadOnly(bits: 20..<21)
        public var wuf: WUF

        /// It can be used when an idle frame request is generated by writing TE = 0, followed by TE = 1 in the USART_CR1 register, in order to respect the TE = 0 minimum period.
        @ReadOnly(bits: 21..<22)
        public var teack: TEACK

        /// Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and kept at reset value. Refer to .
        @ReadOnly(bits: 22..<23)
        public var reack: REACK

        /// Note: If the USART does not support the Smartcard mode, this bit is reserved and kept at reset value. If the USART supports the Smartcard mode and the Smartcard mode is enabled, the TCBGT reset value is ‘1’. Refer to on page 1985.
        @ReadOnly(bits: 25..<26)
        public var tcbgt: TCBGT
    }

    /// USART interrupt flag clear register
    @Register(bitWidth: 32)
    public struct ICR {
        /// Writing 1 to this bit clears the PE flag in the USART_ISR register.
        @WriteOnly(bits: 0..<1)
        public var pecf: PECF

        /// Writing 1 to this bit clears the FE flag in the USART_ISR register.
        @WriteOnly(bits: 1..<2)
        public var fecf: FECF

        /// Writing 1 to this bit clears the NE flag in the USART_ISR register.
        @WriteOnly(bits: 2..<3)
        public var necf: NECF

        /// Writing 1 to this bit clears the ORE flag in the USART_ISR register.
        @WriteOnly(bits: 3..<4)
        public var orecf: ORECF

        /// Writing 1 to this bit clears the IDLE flag in the USART_ISR register.
        @WriteOnly(bits: 4..<5)
        public var idlecf: IDLECF

        /// Writing 1 to this bit clears the TXFE flag in the USART_ISR register.
        @WriteOnly(bits: 5..<6)
        public var txfecf: TXFECF

        /// Writing 1 to this bit clears the TC flag in the USART_ISR register.
        @WriteOnly(bits: 6..<7)
        public var tccf: TCCF

        /// Writing 1 to this bit clears the TCBGT flag in the USART_ISR register.
        @WriteOnly(bits: 7..<8)
        public var tcbgtcf: TCBGTCF

        /// Note: If LIN mode is not supported, this bit is reserved and must be kept at reset value. Refer to .
        @WriteOnly(bits: 8..<9)
        public var lbdcf: LBDCF

        /// Note: If the hardware flow control feature is not supported, this bit is reserved and must be kept at reset value. Refer to .
        @WriteOnly(bits: 9..<10)
        public var ctscf: CTSCF

        /// Note: If the USART does not support the Receiver timeout feature, this bit is reserved and must be kept at reset value. Refer to page 1985.
        @WriteOnly(bits: 11..<12)
        public var rtocf: RTOCF

        /// Note: If the USART does not support Smartcard mode, this bit is reserved and must be kept at reset value. Refer to .
        @WriteOnly(bits: 12..<13)
        public var eobcf: EOBCF

        /// Note: If the USART does not support SPI slave mode, this bit is reserved and must be kept at reset value. Refer to
        @WriteOnly(bits: 13..<14)
        public var udrcf: UDRCF

        /// Writing 1 to this bit clears the CMF flag in the USART_ISR register.
        @WriteOnly(bits: 17..<18)
        public var cmcf: CMCF

        /// Note: If the USART does not support the wakeup from Stop feature, this bit is reserved and must be kept at reset value. Refer to page 1985.
        @WriteOnly(bits: 20..<21)
        public var wucf: WUCF
    }

    /// USART receive data register
    @Register(bitWidth: 32)
    public struct RDR {
        /// When receiving with the parity enabled, the value read in the MSB bit is the received parity bit.
        @ReadOnly(bits: 0..<9)
        public var rdr_field: RDR_FIELD
    }

    /// USART transmit data register
    @Register(bitWidth: 32)
    public struct TDR {
        /// Note: This register must be written only when TXE/TXFNF = 1.
        @ReadWrite(bits: 0..<9)
        public var tdr_field: TDR_FIELD
    }

    /// USART prescaler register
    @Register(bitWidth: 32)
    public struct PRESC {
        /// Note: When PRESCALER is programmed with a value different of the allowed ones, programmed prescaler value is 1011 i.e. input clock divided by 256.
        @ReadWrite(bits: 0..<4)
        public var prescaler: PRESCALER
    }
}

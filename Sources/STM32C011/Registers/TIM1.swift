// Generated by svd2swift.

import MMIO

/// Advanced-control timer
@RegisterBlock
public struct TIM1: Sendable {
    /// TIM1 control register 1
    @RegisterBlock(offset: 0x0)
    public var cr1: Register<CR1>

    /// TIM1 control register 2
    @RegisterBlock(offset: 0x4)
    public var cr2: Register<CR2>

    /// TIM1 slave mode control register
    @RegisterBlock(offset: 0x8)
    public var smcr: Register<SMCR>

    /// TIM1 DMA/interrupt enable register
    @RegisterBlock(offset: 0xc)
    public var dier: Register<DIER>

    /// TIM1 status register
    @RegisterBlock(offset: 0x10)
    public var sr: Register<SR>

    /// TIM1 event generation register
    @RegisterBlock(offset: 0x14)
    public var egr: Register<EGR>

    /// TIM1 capture/compare mode register 1 [alternate]
    @RegisterBlock(offset: 0x18)
    public var ccmr1_input: Register<CCMR1_input>

    /// TIM1 capture/compare mode register 1 [alternate]
    @RegisterBlock(offset: 0x18)
    public var ccmr1_output: Register<CCMR1_output>

    /// TIM1 capture/compare mode register 2 [alternate]
    @RegisterBlock(offset: 0x1c)
    public var ccmr2_input: Register<CCMR2_input>

    /// TIM1 capture/compare mode register 2 [alternate]
    @RegisterBlock(offset: 0x1c)
    public var ccmr2_output: Register<CCMR2_output>

    /// TIM1 capture/compare enable register
    @RegisterBlock(offset: 0x20)
    public var ccer: Register<CCER>

    /// TIM1 counter
    @RegisterBlock(offset: 0x24)
    public var cnt: Register<CNT>

    /// TIM1 prescaler
    @RegisterBlock(offset: 0x28)
    public var psc: Register<PSC>

    /// TIM1 auto-reload register
    @RegisterBlock(offset: 0x2c)
    public var arr: Register<ARR>

    /// TIM1 repetition counter register
    @RegisterBlock(offset: 0x30)
    public var rcr: Register<RCR>

    /// TIM1 capture/compare register 1
    @RegisterBlock(offset: 0x34)
    public var ccr1: Register<CCR1>

    /// TIM1 capture/compare register 2
    @RegisterBlock(offset: 0x38)
    public var ccr2: Register<CCR2>

    /// TIM1 capture/compare register 3
    @RegisterBlock(offset: 0x3c)
    public var ccr3: Register<CCR3>

    /// TIM1 capture/compare register 4
    @RegisterBlock(offset: 0x40)
    public var ccr4: Register<CCR4>

    /// TIM1 break and dead-time register
    @RegisterBlock(offset: 0x44)
    public var bdtr: Register<BDTR>

    /// TIM1 DMA control register
    @RegisterBlock(offset: 0x48)
    public var dcr: Register<DCR>

    /// TIM1 DMA address for full transfer
    @RegisterBlock(offset: 0x4c)
    public var dmar: Register<DMAR>

    /// TIM1 capture/compare mode register 3
    @RegisterBlock(offset: 0x54)
    public var ccmr3: Register<CCMR3>

    /// TIM1 capture/compare register 5
    @RegisterBlock(offset: 0x58)
    public var ccr5: Register<CCR5>

    /// TIM1 capture/compare register 6
    @RegisterBlock(offset: 0x5c)
    public var ccr6: Register<CCR6>

    /// TIM1 alternate function option register 1
    @RegisterBlock(offset: 0x60)
    public var af1: Register<AF1>

    /// TIM1 Alternate function register 2
    @RegisterBlock(offset: 0x64)
    public var af2: Register<AF2>

    /// TIM1 timer input selection register
    @RegisterBlock(offset: 0x68)
    public var tisel: Register<TISEL>
}

extension TIM1 {
    /// TIM1 control register 1
    @Register(bitWidth: 16)
    public struct CR1 {
        /// Note: External clock, gated mode and encoder mode can work only if the CEN bit has been previously set by software. However trigger mode can set the CEN bit automatically by hardware.
        @ReadWrite(bits: 0..<1)
        public var cen: CEN

        /// Buffered registers are then loaded with their preload values.
        @ReadWrite(bits: 1..<2)
        public var udis: UDIS

        /// Update generation through the slave mode controller
        @ReadWrite(bits: 2..<3)
        public var urs: URS

        /// One pulse mode
        @ReadWrite(bits: 3..<4)
        public var opm: OPM

        /// Note: This bit is read only when the timer is configured in Center-aligned mode or Encoder mode.
        @ReadWrite(bits: 4..<5)
        public var dir: DIR

        /// Note: Switch from edge-aligned mode to center-aligned mode as long as the counter is enabled (CEN=1) is not allowed
        @ReadWrite(bits: 5..<7)
        public var cms: CMS

        /// Auto-reload preload enable
        @ReadWrite(bits: 7..<8)
        public var arpe: ARPE

        /// Note: tDTS = 1/fDTS, tCK_INT = 1/fCK_INT.
        @ReadWrite(bits: 8..<10)
        public var ckd: CKD

        /// UIF status bit remapping
        @ReadWrite(bits: 11..<12)
        public var uifremap: UIFREMAP
    }

    /// TIM1 control register 2
    @Register(bitWidth: 32)
    public struct CR2 {
        /// Note: This bit acts only on channels that have a complementary output.
        @ReadWrite(bits: 0..<1)
        public var ccpc: CCPC

        /// Note: This bit acts only on channels that have a complementary output.
        @ReadWrite(bits: 2..<3)
        public var ccus: CCUS

        /// Capture/compare DMA selection
        @ReadWrite(bits: 3..<4)
        public var ccds: CCDS

        /// Note: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.
        @ReadWrite(bits: 4..<7)
        public var mms: MMS

        /// TI1 selection
        @ReadWrite(bits: 7..<8)
        public var ti1s: TI1S

        /// Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).
        @ReadWrite(bits: 8..<9)
        public var ois1: OIS1

        /// Note: This bit can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).
        @ReadWrite(bits: 9..<10)
        public var ois1n: OIS1N

        /// Refer to OIS1 bit
        @ReadWrite(bits: 10..<11)
        public var ois2: OIS2

        /// Refer to OIS1N bit
        @ReadWrite(bits: 11..<12)
        public var ois2n: OIS2N

        /// Refer to OIS1 bit
        @ReadWrite(bits: 12..<13)
        public var ois3: OIS3

        /// Refer to OIS1N bit
        @ReadWrite(bits: 13..<14)
        public var ois3n: OIS3N

        /// Refer to OIS1 bit
        @ReadWrite(bits: 14..<15)
        public var ois4: OIS4

        /// Refer to OIS1 bit
        @ReadWrite(bits: 16..<17)
        public var ois5: OIS5

        /// Refer to OIS1 bit
        @ReadWrite(bits: 18..<19)
        public var ois6: OIS6

        /// Note: The clock of the slave timer or ADC must be enabled prior to receive events from the master timer, and must not be changed on-the-fly while triggers are received from the master timer.
        @ReadWrite(bits: 20..<24)
        public var mms2: MMS2
    }

    /// TIM1 slave mode control register
    @Register(bitWidth: 32)
    public struct SMCR {
        /// Note: The clock of the slave peripherals (timer, ADC, ...) receiving the TRGO or the TRGO2 signals must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer.
        @ReadWrite(bits: 0..<3)
        public var sms1: SMS1

        /// This bit is used to select the OCREF clear source.
        @ReadWrite(bits: 3..<4)
        public var occs: OCCS

        /// Note: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition.
        @ReadWrite(bits: 4..<7)
        public var ts1: TS1

        /// Master/slave mode
        @ReadWrite(bits: 7..<8)
        public var msm: MSM

        /// This bit-field then defines the frequency used to sample ETRP signal and the length of the digital filter applied to ETRP. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:
        @ReadWrite(bits: 8..<12)
        public var etf: ETF

        /// External trigger signal ETRP frequency must be at most 1/4 of fCK_INT frequency. A prescaler can be enabled to reduce ETRP frequency. It is useful when inputting fast external clocks.
        @ReadWrite(bits: 12..<14)
        public var etps: ETPS

        /// If external clock mode 1 and external clock mode 2 are enabled at the same time, the external clock input is ETRF.
        @ReadWrite(bits: 14..<15)
        public var ece: ECE

        /// This bit selects whether ETR or ETR is used for trigger operations
        @ReadWrite(bits: 15..<16)
        public var etp: ETP

        /// Note: The clock of the slave peripherals (timer, ADC, ...) receiving the TRGO or the TRGO2 signals must be enabled prior to receive events from the master timer, and the clock frequency (prescaler) must not be changed on-the-fly while triggers are received from the master timer.
        @ReadWrite(bits: 16..<17)
        public var sms2: SMS2

        /// Note: These bits must be changed only when they are not used (e.g. when SMS=000) to avoid wrong edge detections at the transition.
        @ReadWrite(bits: 20..<22)
        public var ts2: TS2
    }

    /// TIM1 DMA/interrupt enable register
    @Register(bitWidth: 16)
    public struct DIER {
        /// Update interrupt enable
        @ReadWrite(bits: 0..<1)
        public var uie: UIE

        /// Capture/Compare 1 interrupt enable
        @ReadWrite(bits: 1..<2)
        public var cc1ie: CC1IE

        /// Capture/Compare 2 interrupt enable
        @ReadWrite(bits: 2..<3)
        public var cc2ie: CC2IE

        /// Capture/Compare 3 interrupt enable
        @ReadWrite(bits: 3..<4)
        public var cc3ie: CC3IE

        /// Capture/Compare 4 interrupt enable
        @ReadWrite(bits: 4..<5)
        public var cc4ie: CC4IE

        /// COM interrupt enable
        @ReadWrite(bits: 5..<6)
        public var comie: COMIE

        /// Trigger interrupt enable
        @ReadWrite(bits: 6..<7)
        public var tie: TIE

        /// Break interrupt enable
        @ReadWrite(bits: 7..<8)
        public var bie: BIE

        /// Update DMA request enable
        @ReadWrite(bits: 8..<9)
        public var ude: UDE

        /// Capture/Compare 1 DMA request enable
        @ReadWrite(bits: 9..<10)
        public var cc1de: CC1DE

        /// Capture/Compare 2 DMA request enable
        @ReadWrite(bits: 10..<11)
        public var cc2de: CC2DE

        /// Capture/Compare 3 DMA request enable
        @ReadWrite(bits: 11..<12)
        public var cc3de: CC3DE

        /// Capture/Compare 4 DMA request enable
        @ReadWrite(bits: 12..<13)
        public var cc4de: CC4DE

        /// COM DMA request enable
        @ReadWrite(bits: 13..<14)
        public var comde: COMDE

        /// Trigger DMA request enable
        @ReadWrite(bits: 14..<15)
        public var tde: TDE
    }

    /// TIM1 status register
    @Register(bitWidth: 32)
    public struct SR {
        /// When CNT is reinitialized by a trigger event (refer to control register (TIM1_SMCRTIMx_SMCR)N/A), if URS=0 and UDIS=0 in the TIMx_CR1 register.
        @ReadWrite(bits: 0..<1)
        public var uif: UIF

        /// If channel CC1 is configured as input: this bit is set when counter value has been captured in TIMx_CCR1 register (an edge has been detected on IC1, as per the edge sensitivity defined with the CC1P and CC1NP bits setting, in TIMx_CCER).
        @ReadWrite(bits: 1..<2)
        public var cc1if: CC1IF

        /// Refer to CC1IF description
        @ReadWrite(bits: 2..<3)
        public var cc2if: CC2IF

        /// Refer to CC1IF description
        @ReadWrite(bits: 3..<4)
        public var cc3if: CC3IF

        /// Refer to CC1IF description
        @ReadWrite(bits: 4..<5)
        public var cc4if: CC4IF

        /// This flag is set by hardware on COM event (when Capture/compare Control bits - CCxE, CCxNE, OCxM - have been updated). It is cleared by software.
        @ReadWrite(bits: 5..<6)
        public var comif: COMIF

        /// This flag is set by hardware on the TRG trigger event (active edge detected on TRGI input when the slave mode controller is enabled in all modes but gated mode. It is set when the counter starts or stops when gated mode is selected. It is cleared by software.
        @ReadWrite(bits: 6..<7)
        public var tif: TIF

        /// This flag is set by hardware as soon as the break input goes active. It can be cleared by software if the break input is not active.
        @ReadWrite(bits: 7..<8)
        public var bif: BIF

        /// This flag is set by hardware as soon as the break 2 input goes active. It can be cleared by software if the break 2 input is not active.
        @ReadWrite(bits: 8..<9)
        public var b2if: B2IF

        /// This flag is set by hardware only when the corresponding channel is configured in input capture mode. It is cleared by software by writing it to ‘0’.
        @ReadWrite(bits: 9..<10)
        public var cc1of: CC1OF

        /// Refer to CC1OF description
        @ReadWrite(bits: 10..<11)
        public var cc2of: CC2OF

        /// Refer to CC1OF description
        @ReadWrite(bits: 11..<12)
        public var cc3of: CC3OF

        /// Refer to CC1OF description
        @ReadWrite(bits: 12..<13)
        public var cc4of: CC4OF

        /// This flag must be reset to re-start PWM operation.
        @ReadWrite(bits: 13..<14)
        public var sbif: SBIF

        /// Refer to CC1IF description (Note: Channel 5 can only be configured as output)
        @ReadWrite(bits: 16..<17)
        public var cc5if: CC5IF

        /// Refer to CC1IF description (Note: Channel 6 can only be configured as output)
        @ReadWrite(bits: 17..<18)
        public var cc6if: CC6IF
    }

    /// TIM1 event generation register
    @Register(bitWidth: 16)
    public struct EGR {
        /// This bit can be set by software, it is automatically cleared by hardware.
        @WriteOnly(bits: 0..<1)
        public var ug: UG

        /// The current value of the counter is captured in TIMx_CCR1 register. The CC1IF flag is set, the corresponding interrupt or DMA request is sent if enabled. The CC1OF flag is set if the CC1IF flag was already high.
        @WriteOnly(bits: 1..<2)
        public var cc1g: CC1G

        /// Refer to CC1G description
        @WriteOnly(bits: 2..<3)
        public var cc2g: CC2G

        /// Refer to CC1G description
        @WriteOnly(bits: 3..<4)
        public var cc3g: CC3G

        /// Refer to CC1G description
        @WriteOnly(bits: 4..<5)
        public var cc4g: CC4G

        /// Note: This bit acts only on channels having a complementary output.
        @WriteOnly(bits: 5..<6)
        public var comg: COMG

        /// This bit is set by software in order to generate an event, it is automatically cleared by hardware.
        @WriteOnly(bits: 6..<7)
        public var tg: TG

        /// This bit is set by software in order to generate an event, it is automatically cleared by hardware.
        @WriteOnly(bits: 7..<8)
        public var bg: BG

        /// This bit is set by software in order to generate an event, it is automatically cleared by hardware.
        @WriteOnly(bits: 8..<9)
        public var b2g: B2G
    }

    /// TIM1 capture/compare mode register 1 [alternate]
    @Register(bitWidth: 32)
    public struct CCMR1_input {
        /// Note: CC1S bits are writable only when the channel is OFF (CC1E = ‘0’ in TIMx_CCER).
        @ReadWrite(bits: 0..<2)
        public var cc1s: CC1S

        /// This bit-field defines the ratio of the prescaler acting on CC1 input (IC1). The prescaler is reset as soon as CC1E=’0’ (TIMx_CCER register).
        @ReadWrite(bits: 2..<4)
        public var ic1psc: IC1PSC

        /// This bit-field defines the frequency used to sample TI1 input and the length of the digital filter applied to TI1. The digital filter is made of an event counter in which N consecutive events are needed to validate a transition on the output:
        @ReadWrite(bits: 4..<8)
        public var ic1f: IC1F

        /// Note: CC2S bits are writable only when the channel is OFF (CC2E = ‘0’ in TIMx_CCER).
        @ReadWrite(bits: 8..<10)
        public var cc2s: CC2S

        /// Refer to IC1PSC[1:0] description.
        @ReadWrite(bits: 10..<12)
        public var ic2psc: IC2PSC

        /// Refer to IC1F[3:0] description.
        @ReadWrite(bits: 12..<16)
        public var ic2f: IC2F
    }

    /// TIM1 capture/compare mode register 1 [alternate]
    @Register(bitWidth: 32)
    public struct CCMR1_output {
        /// Note: CC1S bits are writable only when the channel is OFF (CC1E = ‘0’ in TIMx_CCER).
        @ReadWrite(bits: 0..<2)
        public var cc1s: CC1S

        /// This bit decreases the latency between a trigger event and a transition on the timer output. It must be used in one-pulse mode (OPM bit set in TIMx_CR1 register), to have the output pulse starting as soon as possible after the starting trigger.
        @ReadWrite(bits: 2..<3)
        public var oc1fe: OC1FE

        /// The PWM mode can be used without validating the preload register only in one pulse mode (OPM bit set in TIMx_CR1 register). Else the behavior is not guaranteed.
        @ReadWrite(bits: 3..<4)
        public var oc1pe: OC1PE

        /// Note: The OC1M[3] bit is not contiguous, located in bit 16.
        @ReadWrite(bits: 4..<7)
        public var oc1m1: OC1M1

        /// Output Compare 1 clear enable
        @ReadWrite(bits: 7..<8)
        public var oc1ce: OC1CE

        /// Note: CC2S bits are writable only when the channel is OFF (CC2E = ‘0’ in TIMx_CCER).
        @ReadWrite(bits: 8..<10)
        public var cc2s: CC2S

        /// Refer to OC1FE description.
        @ReadWrite(bits: 10..<11)
        public var oc2fe: OC2FE

        /// Refer to OC1PE description.
        @ReadWrite(bits: 11..<12)
        public var oc2pe: OC2PE

        /// Refer to OC1M[3:0] description.
        @ReadWrite(bits: 12..<15)
        public var oc2m1: OC2M1

        /// Refer to OC1CE description.
        @ReadWrite(bits: 15..<16)
        public var oc2ce: OC2CE

        /// Note: The OC1M[3] bit is not contiguous, located in bit 16.
        @ReadWrite(bits: 16..<17)
        public var oc1m2: OC1M2

        /// Refer to OC1M[3:0] description.
        @ReadWrite(bits: 24..<25)
        public var oc2m2: OC2M2
    }

    /// TIM1 capture/compare mode register 2 [alternate]
    @Register(bitWidth: 32)
    public struct CCMR2_input {
        /// Note: CC3S bits are writable only when the channel is OFF (CC3E = ‘0’ in TIMx_CCER).
        @ReadWrite(bits: 0..<2)
        public var cc3s: CC3S

        /// Refer to IC1PSC[1:0] description.
        @ReadWrite(bits: 2..<4)
        public var ic3psc: IC3PSC

        /// Refer to IC1F[3:0] description.
        @ReadWrite(bits: 4..<8)
        public var ic3f: IC3F

        /// Note: CC4S bits are writable only when the channel is OFF (CC4E = ‘0’ in TIMx_CCER).
        @ReadWrite(bits: 8..<10)
        public var cc4s: CC4S

        /// Refer to IC1PSC[1:0] description.
        @ReadWrite(bits: 10..<12)
        public var ic4psc: IC4PSC

        /// Refer to IC1F[3:0] description.
        @ReadWrite(bits: 12..<16)
        public var ic4f: IC4F
    }

    /// TIM1 capture/compare mode register 2 [alternate]
    @Register(bitWidth: 32)
    public struct CCMR2_output {
        /// Note: CC3S bits are writable only when the channel is OFF (CC3E = ‘0’ in TIMx_CCER).
        @ReadWrite(bits: 0..<2)
        public var cc3s: CC3S

        /// Refer to OC1FE description.
        @ReadWrite(bits: 2..<3)
        public var oc3fe: OC3FE

        /// Refer to OC1PE description.
        @ReadWrite(bits: 3..<4)
        public var oc3pe: OC3PE

        /// Refer to OC1M[3:0] description.
        @ReadWrite(bits: 4..<7)
        public var oc3m1: OC3M1

        /// Refer to OC1CE description.
        @ReadWrite(bits: 7..<8)
        public var oc3ce: OC3CE

        /// Note: CC4S bits are writable only when the channel is OFF (CC4E = ‘0’ in TIMx_CCER).
        @ReadWrite(bits: 8..<10)
        public var cc4s: CC4S

        /// Refer to OC1FE description.
        @ReadWrite(bits: 10..<11)
        public var oc4fe: OC4FE

        /// Refer to OC1PE description.
        @ReadWrite(bits: 11..<12)
        public var oc4pe: OC4PE

        /// Refer to OC3M[3:0] description.
        @ReadWrite(bits: 12..<15)
        public var oc4m1: OC4M1

        /// Refer to OC1CE description.
        @ReadWrite(bits: 15..<16)
        public var oc4ce: OC4CE

        /// Refer to OC1M[3:0] description.
        @ReadWrite(bits: 16..<17)
        public var oc3m2: OC3M2

        /// Refer to OC3M[3:0] description.
        @ReadWrite(bits: 24..<25)
        public var oc4m2: OC4M2
    }

    /// TIM1 capture/compare enable register
    @Register(bitWidth: 32)
    public struct CCER {
        /// Note: On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1E active bit takes the new value from the preloaded bit only when a Commutation event is generated.
        @ReadWrite(bits: 0..<1)
        public var cc1e: CC1E

        /// On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1P active bit takes the new value from the preloaded bit only when a Commutation event is generated.
        @ReadWrite(bits: 1..<2)
        public var cc1p: CC1P

        /// On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NE active bit takes the new value from the preloaded bit only when a Commutation event is generated.
        @ReadWrite(bits: 2..<3)
        public var cc1ne: CC1NE

        /// On channels having a complementary output, this bit is preloaded. If the CCPC bit is set in the TIMx_CR2 register then the CC1NP active bit takes the new value from the preloaded bit only when a Commutation event is generated.
        @ReadWrite(bits: 3..<4)
        public var cc1np: CC1NP

        /// Refer to CC1E description
        @ReadWrite(bits: 4..<5)
        public var cc2e: CC2E

        /// Refer to CC1P description
        @ReadWrite(bits: 5..<6)
        public var cc2p: CC2P

        /// Refer to CC1NE description
        @ReadWrite(bits: 6..<7)
        public var cc2ne: CC2NE

        /// Refer to CC1NP description
        @ReadWrite(bits: 7..<8)
        public var cc2np: CC2NP

        /// Refer to CC1E description
        @ReadWrite(bits: 8..<9)
        public var cc3e: CC3E

        /// Refer to CC1P description
        @ReadWrite(bits: 9..<10)
        public var cc3p: CC3P

        /// Refer to CC1NE description
        @ReadWrite(bits: 10..<11)
        public var cc3ne: CC3NE

        /// Refer to CC1NP description
        @ReadWrite(bits: 11..<12)
        public var cc3np: CC3NP

        /// Refer to CC1E description
        @ReadWrite(bits: 12..<13)
        public var cc4e: CC4E

        /// Refer to CC1P description
        @ReadWrite(bits: 13..<14)
        public var cc4p: CC4P

        /// Refer to CC1NP description
        @ReadWrite(bits: 15..<16)
        public var cc4np: CC4NP

        /// Refer to CC1E description
        @ReadWrite(bits: 16..<17)
        public var cc5e: CC5E

        /// Refer to CC1P description
        @ReadWrite(bits: 17..<18)
        public var cc5p: CC5P

        /// Refer to CC1E description
        @ReadWrite(bits: 20..<21)
        public var cc6e: CC6E

        /// Refer to CC1P description
        @ReadWrite(bits: 21..<22)
        public var cc6p: CC6P
    }

    /// TIM1 counter
    @Register(bitWidth: 32)
    public struct CNT {
        /// Counter value
        @ReadWrite(bits: 0..<16)
        public var cnt_field: CNT_FIELD

        /// This bit is a read-only copy of the UIF bit of the TIMx_ISR register. If the UIFREMAP bit in the TIMxCR1 is reset, bit 31 is reserved and read at 0.
        @ReadOnly(bits: 31..<32)
        public var uifcpy: UIFCPY
    }

    /// TIM1 prescaler
    @Register(bitWidth: 16)
    public struct PSC {
        /// PSC contains the value to be loaded in the active prescaler register at each update event (including when the counter is cleared through UG bit of TIMx_EGR register or through trigger controller when configured in “reset mode”).
        @ReadWrite(bits: 0..<16)
        public var psc_field: PSC_FIELD
    }

    /// TIM1 auto-reload register
    @Register(bitWidth: 16)
    public struct ARR {
        /// The counter is blocked while the auto-reload value is null.
        @ReadWrite(bits: 0..<16)
        public var arr_field: ARR_FIELD
    }

    /// TIM1 repetition counter register
    @Register(bitWidth: 16)
    public struct RCR {
        /// the number of half PWM period in center-aligned mode.
        @ReadWrite(bits: 0..<16)
        public var rep: REP
    }

    /// TIM1 capture/compare register 1
    @Register(bitWidth: 16)
    public struct CCR1 {
        /// If channel CC1 is configured as input: CR1 is the counter value transferred by the last input capture 1 event (IC1). The TIMx_CCR1 register is read-only and cannot be programmed.
        @ReadWrite(bits: 0..<16)
        public var ccr1_field: CCR1_FIELD
    }

    /// TIM1 capture/compare register 2
    @Register(bitWidth: 16)
    public struct CCR2 {
        /// If channel CC2 is configured as input: CCR2 is the counter value transferred by the last input capture 2 event (IC2). The TIMx_CCR2 register is read-only and cannot be programmed.
        @ReadWrite(bits: 0..<16)
        public var ccr2_field: CCR2_FIELD
    }

    /// TIM1 capture/compare register 3
    @Register(bitWidth: 16)
    public struct CCR3 {
        /// If channel CC3 is configured as input: CCR3 is the counter value transferred by the last input capture 3 event (IC3). The TIMx_CCR3 register is read-only and cannot be programmed.
        @ReadWrite(bits: 0..<16)
        public var ccr3_field: CCR3_FIELD
    }

    /// TIM1 capture/compare register 4
    @Register(bitWidth: 16)
    public struct CCR4 {
        /// If channel CC4 is configured as input: CCR4 is the counter value transferred by the last input capture 4 event (IC4). The TIMx_CCR4 register is read-only and cannot be programmed.
        @ReadWrite(bits: 0..<16)
        public var ccr4_field: CCR4_FIELD
    }

    /// TIM1 break and dead-time register
    @Register(bitWidth: 32)
    public struct BDTR {
        /// Note: This bit-field can not be modified as long as LOCK level 1, 2 or 3 has been programmed (LOCK bits in TIMx_BDTR register).
        @ReadWrite(bits: 0..<8)
        public var dtg: DTG

        /// Note: The LOCK bits can be written only once after the reset. Once the TIMx_BDTR register has been written, their content is frozen until the next reset.
        @ReadWrite(bits: 8..<10)
        public var lock: LOCK

        /// Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).
        @ReadWrite(bits: 10..<11)
        public var ossi: OSSI

        /// Note: This bit can not be modified as soon as the LOCK level 2 has been programmed (LOCK bits in TIMx_BDTR register).
        @ReadWrite(bits: 11..<12)
        public var ossr: OSSR

        /// Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.
        @ReadWrite(bits: 12..<13)
        public var bke: BKE

        /// Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.
        @ReadWrite(bits: 13..<14)
        public var bkp: BKP

        /// Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
        @ReadWrite(bits: 14..<15)
        public var aoe: AOE

        /// See OC/OCN enable description for more details (enable register (TIM1_CCERTIMx_CCER)N/A).
        @ReadWrite(bits: 15..<16)
        public var moe: MOE

        /// Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
        @ReadWrite(bits: 16..<20)
        public var bkf: BKF

        /// Note: This bit cannot be modified when LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
        @ReadWrite(bits: 20..<24)
        public var bk2f: BK2F

        /// Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.
        @ReadWrite(bits: 24..<25)
        public var bk2e: BK2E

        /// Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.
        @ReadWrite(bits: 25..<26)
        public var bk2p: BK2P

        /// Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.
        @ReadWrite(bits: 26..<27)
        public var bkdsrm: BKDSRM

        /// Refer to BKDSRM description
        @ReadWrite(bits: 27..<28)
        public var bk2dsrm: BK2DSRM

        /// Note: Any write operation to this bit takes a delay of 1 APB clock cycle to become effective.
        @ReadWrite(bits: 28..<29)
        public var bkbid: BKBID

        /// Refer to BKBID description
        @ReadWrite(bits: 29..<30)
        public var bk2bid: BK2BID
    }

    /// TIM1 DMA control register
    @Register(bitWidth: 16)
    public struct DCR {
        /// ...
        @ReadWrite(bits: 0..<5)
        public var dba: DBA

        /// If the DMA Data Size is configured in bytes, the data is also transferred to 7 registers: the first register contains the first MSB byte, the second register, the first LSB byte and so on. So with the transfer Timer, one also has to specify the size of data transferred by DMA.
        @ReadWrite(bits: 8..<13)
        public var dbl: DBL
    }

    /// TIM1 DMA address for full transfer
    @Register(bitWidth: 32)
    public struct DMAR {
        /// where TIMx_CR1 address is the address of the control register 1, DBA is the DMA base address configured in TIMx_DCR register, DMA index is automatically controlled by the DMA transfer, and ranges from 0 to DBL (DBL configured in TIMx_DCR).
        @ReadWrite(bits: 0..<32)
        public var dmab: DMAB
    }

    /// TIM1 capture/compare mode register 3
    @Register(bitWidth: 32)
    public struct CCMR3 {
        /// Refer to OC1FE description.
        @ReadWrite(bits: 2..<3)
        public var oc5fe: OC5FE

        /// Refer to OC1PE description.
        @ReadWrite(bits: 3..<4)
        public var oc5pe: OC5PE

        /// Refer to OC1M description.
        @ReadWrite(bits: 4..<7)
        public var oc5m1: OC5M1

        /// Refer to OC1CE description.
        @ReadWrite(bits: 7..<8)
        public var oc5ce: OC5CE

        /// Refer to OC1FE description.
        @ReadWrite(bits: 10..<11)
        public var oc6fe: OC6FE

        /// Refer to OC1PE description.
        @ReadWrite(bits: 11..<12)
        public var oc6pe: OC6PE

        /// Refer to OC1M description.
        @ReadWrite(bits: 12..<15)
        public var oc6m1: OC6M1

        /// Refer to OC1CE description.
        @ReadWrite(bits: 15..<16)
        public var oc6ce: OC6CE

        /// Refer to OC1M description.
        @ReadWrite(bits: 16..<17)
        public var oc5m2: OC5M2

        /// Refer to OC1M description.
        @ReadWrite(bits: 24..<25)
        public var oc6m2: OC6M2
    }

    /// TIM1 capture/compare register 5
    @Register(bitWidth: 32)
    public struct CCR5 {
        /// The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on OC5 output.
        @ReadWrite(bits: 0..<16)
        public var ccr5_field: CCR5_FIELD

        /// Note: it is also possible to apply this distortion on combined PWM signals.
        @ReadWrite(bits: 29..<30)
        public var gc5c1: GC5C1

        /// Note: it is also possible to apply this distortion on combined PWM signals.
        @ReadWrite(bits: 30..<31)
        public var gc5c2: GC5C2

        /// Note: it is also possible to apply this distortion on combined PWM signals.
        @ReadWrite(bits: 31..<32)
        public var gc5c3: GC5C3
    }

    /// TIM1 capture/compare register 6
    @Register(bitWidth: 16)
    public struct CCR6 {
        /// The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on OC6 output.
        @ReadWrite(bits: 0..<16)
        public var ccr6_field: CCR6_FIELD
    }

    /// TIM1 alternate function option register 1
    @Register(bitWidth: 32)
    public struct AF1 {
        /// Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
        @ReadWrite(bits: 0..<1)
        public var bkine: BKINE

        /// Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
        @ReadWrite(bits: 9..<10)
        public var bkinp: BKINP

        /// Note: These bits can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
        @ReadWrite(bits: 14..<18)
        public var etrsel: ETRSEL
    }

    /// TIM1 Alternate function register 2
    @Register(bitWidth: 32)
    public struct AF2 {
        /// Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
        @ReadWrite(bits: 0..<1)
        public var bk2ine: BK2INE

        /// Note: This bit can not be modified as long as LOCK level 1 has been programmed (LOCK bits in TIMx_BDTR register).
        @ReadWrite(bits: 9..<10)
        public var bk2inp: BK2INP
    }

    /// TIM1 timer input selection register
    @Register(bitWidth: 32)
    public struct TISEL {
        /// Others: Reserved
        @ReadWrite(bits: 0..<4)
        public var ti1sel: TI1SEL

        /// Others: Reserved
        @ReadWrite(bits: 8..<12)
        public var ti2sel: TI2SEL

        /// Others: Reserved
        @ReadWrite(bits: 16..<20)
        public var ti3sel: TI3SEL

        /// Others: Reserved
        @ReadWrite(bits: 24..<28)
        public var ti4sel: TI4SEL
    }
}

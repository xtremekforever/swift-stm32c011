// Generated by svd2swift.

import MMIO

/// Analog to Digital Converter
@RegisterBlock
public struct ADC: Sendable {
    /// ADC interrupt and status register
    @RegisterBlock(offset: 0x0)
    public var isr: Register<ISR>

    /// ADC interrupt enable register
    @RegisterBlock(offset: 0x4)
    public var ier: Register<IER>

    /// ADC control register
    @RegisterBlock(offset: 0x8)
    public var cr: Register<CR>

    /// ADC configuration register 1
    @RegisterBlock(offset: 0xc)
    public var cfgr1: Register<CFGR1>

    /// ADC configuration register 2
    @RegisterBlock(offset: 0x10)
    public var cfgr2: Register<CFGR2>

    /// ADC sampling time register
    @RegisterBlock(offset: 0x14)
    public var smpr: Register<SMPR>

    /// ADC watchdog threshold register
    @RegisterBlock(offset: 0x20)
    public var awd1tr: Register<AWD1TR>

    /// ADC watchdog threshold register
    @RegisterBlock(offset: 0x24)
    public var awd2tr: Register<AWD2TR>

    /// ADC channel selection register [alternate]
    @RegisterBlock(offset: 0x28)
    public var chselr0: Register<CHSELR0>

    /// ADC channel selection register [alternate]
    @RegisterBlock(offset: 0x28)
    public var chselr1: Register<CHSELR1>

    /// ADC watchdog threshold register
    @RegisterBlock(offset: 0x2c)
    public var awd3tr: Register<AWD3TR>

    /// ADC data register
    @RegisterBlock(offset: 0x40)
    public var dr: Register<DR>

    /// ADC Analog Watchdog 2 Configuration register
    @RegisterBlock(offset: 0xa0)
    public var awd2cr: Register<AWD2CR>

    /// ADC Analog Watchdog 3 Configuration register
    @RegisterBlock(offset: 0xa4)
    public var awd3cr: Register<AWD3CR>

    /// ADC Calibration factor
    @RegisterBlock(offset: 0xb4)
    public var calfact: Register<CALFACT>

    /// ADC common configuration register
    @RegisterBlock(offset: 0x308)
    public var ccr: Register<CCR>
}

extension ADC {
    /// ADC interrupt and status register
    @Register(bitWidth: 32)
    public struct ISR {
        /// It is cleared by software writing 1 to it.
        @ReadWrite(bits: 0..<1)
        public var adrdy: ADRDY

        /// This bit is set by hardware during the conversion, at the end of the sampling phase.It is cleared by software by programming it to ‘1’.
        @ReadWrite(bits: 1..<2)
        public var eosmp: EOSMP

        /// This bit is set by hardware at the end of each conversion of a channel when a new data result is available in the ADC_DR register. It is cleared by software writing 1 to it or by reading the ADC_DR register.
        @ReadWrite(bits: 2..<3)
        public var eoc: EOC

        /// This bit is set by hardware at the end of the conversion of a sequence of channels selected by the CHSEL bits. It is cleared by software writing 1 to it.
        @ReadWrite(bits: 3..<4)
        public var eos: EOS

        /// This bit is set by hardware when an overrun occurs, meaning that a new conversion has complete while the EOC flag was already set. It is cleared by software writing 1 to it.
        @ReadWrite(bits: 4..<5)
        public var ovr: OVR

        /// This bit is set by hardware when the converted voltage crosses the values programmed in ADC_TR1 and ADC_HR1 registers. It is cleared by software by programming it to 1.
        @ReadWrite(bits: 7..<8)
        public var awd1: AWD1

        /// This bit is set by hardware when the converted voltage crosses the values programmed in ADC_AWD2TR and ADC_AWD2TR registers. It is cleared by software programming it it.
        @ReadWrite(bits: 8..<9)
        public var awd2: AWD2

        /// This bit is set by hardware when the converted voltage crosses the values programmed in ADC_AWD3TR and ADC_AWD3TR registers. It is cleared by software by programming it to 1.
        @ReadWrite(bits: 9..<10)
        public var awd3: AWD3

        /// This bit is set by hardware when calibration is complete. It is cleared by software writing 1 to it.
        @ReadWrite(bits: 11..<12)
        public var eocal: EOCAL

        /// Note: When the software configures the channels (by programming ADC_CHSELR or changing CHSELRMOD or SCANDIR), it must wait until the CCRDY flag rises before configuring again or starting conversions, otherwise the new configuration (or the START bit) is ignored. Once the flag is asserted, if the software needs to configure again the channels, it must clear the CCRDY flag before proceeding with a new configuration.
        @ReadWrite(bits: 13..<14)
        public var ccrdy: CCRDY
    }

    /// ADC interrupt enable register
    @Register(bitWidth: 32)
    public struct IER {
        /// Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        @ReadWrite(bits: 0..<1)
        public var adrdyie: ADRDYIE

        /// Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        @ReadWrite(bits: 1..<2)
        public var eosmpie: EOSMPIE

        /// Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        @ReadWrite(bits: 2..<3)
        public var eocie: EOCIE

        /// Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        @ReadWrite(bits: 3..<4)
        public var eosie: EOSIE

        /// Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        @ReadWrite(bits: 4..<5)
        public var ovrie: OVRIE

        /// Note: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        @ReadWrite(bits: 7..<8)
        public var awd1ie: AWD1IE

        /// Note: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        @ReadWrite(bits: 8..<9)
        public var awd2ie: AWD2IE

        /// Note: The Software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        @ReadWrite(bits: 9..<10)
        public var awd3ie: AWD3IE

        /// Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        @ReadWrite(bits: 11..<12)
        public var eocalie: EOCALIE

        /// Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        @ReadWrite(bits: 13..<14)
        public var ccrdyie: CCRDYIE
    }

    /// ADC control register
    @Register(bitWidth: 32)
    public struct CR {
        /// Note: The software is allowed to set ADEN only when all bits of ADC_CR registers are 0 (ADCAL = 0, ADSTP = 0, ADSTART = 0, ADDIS = 0 and ADEN = 0)
        @ReadWrite(bits: 0..<1)
        public var aden: ADEN

        /// Note: Setting ADDIS to ‘1’ is only effective when ADEN = 1 and ADSTART = 0 (which ensures that no conversion is ongoing)
        @ReadWrite(bits: 1..<2)
        public var addis: ADDIS

        /// After writing to ADC_CHSELR register or changing CHSELRMOD or SCANDIRW, it is mandatory to wait until CCRDY flag is asserted before setting ADSTART, otherwise, the value written to ADSTART is ignored.
        @ReadWrite(bits: 2..<3)
        public var adstart: ADSTART

        /// Note: Setting ADSTP to ‘1’ is only effective when ADSTART = 1 and ADDIS = 0 (ADC is enabled and may be converting and there is no pending request to disable the ADC)
        @ReadWrite(bits: 4..<5)
        public var adstp: ADSTP

        /// Note: The software is allowed to program this bit field only when the ADC is disabled (ADCAL = 0, ADSTART = 0, ADSTP = 0, ADDIS = 0 and ADEN = 0).
        @ReadWrite(bits: 28..<29)
        public var advregen: ADVREGEN

        /// The software is allowed to update the calibration factor by writing ADC_CALFACT only when ADEN = 1 and ADSTART = 0 (ADC enabled and no conversion is ongoing).
        @ReadWrite(bits: 31..<32)
        public var adcal: ADCAL
    }

    /// ADC configuration register 1
    @Register(bitWidth: 32)
    public struct CFGR1 {
        /// Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        @ReadWrite(bits: 0..<1)
        public var dmaen: DMAEN

        /// Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        @ReadWrite(bits: 1..<2)
        public var dmacfg: DMACFG

        /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        @ReadWrite(bits: 2..<3)
        public var scandir: SCANDIR

        /// Note: The software is allowed to write these bits only when ADEN = 0.
        @ReadWrite(bits: 3..<5)
        public var res: RES

        /// Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        @ReadWrite(bits: 5..<6)
        public var align: ALIGN

        /// Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        @ReadWrite(bits: 6..<9)
        public var extsel: EXTSEL

        /// Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        @ReadWrite(bits: 10..<12)
        public var exten: EXTEN

        /// Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        @ReadWrite(bits: 12..<13)
        public var ovrmod: OVRMOD

        /// The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        @ReadWrite(bits: 13..<14)
        public var cont: CONT

        /// Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        @ReadWrite(bits: 14..<15)
        public var wait: WAIT

        /// Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        @ReadWrite(bits: 15..<16)
        public var autoff: AUTOFF

        /// The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        @ReadWrite(bits: 16..<17)
        public var discen: DISCEN

        /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        @ReadWrite(bits: 21..<22)
        public var chselrmod: CHSELRMOD

        /// Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        @ReadWrite(bits: 22..<23)
        public var awd1sgl: AWD1SGL

        /// Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        @ReadWrite(bits: 23..<24)
        public var awd1en: AWD1EN

        /// The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        @ReadWrite(bits: 26..<31)
        public var awd1ch: AWD1CH
    }

    /// ADC configuration register 2
    @Register(bitWidth: 32)
    public struct CFGR2 {
        /// Note: Software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 0..<1)
        public var ovse: OVSE

        /// Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 2..<5)
        public var ovsr: OVSR

        /// Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 5..<9)
        public var ovss: OVSS

        /// Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 9..<10)
        public var tovs: TOVS

        /// Note: The software is allowed to write this bit only when ADSTART bit is cleared to 0 (this ensures that no conversion is ongoing).
        @ReadWrite(bits: 29..<30)
        public var lftrig: LFTRIG

        /// Note: The software is allowed to write these bits only when the ADC is disabled (ADCAL = 0, ADSTART = 0, ADSTP = 0, ADDIS = 0 and ADEN = 0).
        @ReadWrite(bits: 30..<32)
        public var ckmode: CKMODE
    }

    /// ADC sampling time register
    @Register(bitWidth: 32)
    public struct SMPR {
        /// Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 0..<3)
        public var smp1: SMP1

        /// Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 4..<7)
        public var smp2: SMP2

        /// Refer to for the maximum number of channels.
        @ReadWrite(bits: 8..<9)
        public var smpsel0: SMPSEL0

        /// Refer to for the maximum number of channels.
        @ReadWrite(bits: 9..<10)
        public var smpsel1: SMPSEL1

        /// Refer to for the maximum number of channels.
        @ReadWrite(bits: 10..<11)
        public var smpsel2: SMPSEL2

        /// Refer to for the maximum number of channels.
        @ReadWrite(bits: 11..<12)
        public var smpsel3: SMPSEL3

        /// Refer to for the maximum number of channels.
        @ReadWrite(bits: 12..<13)
        public var smpsel4: SMPSEL4

        /// Refer to for the maximum number of channels.
        @ReadWrite(bits: 13..<14)
        public var smpsel5: SMPSEL5

        /// Refer to for the maximum number of channels.
        @ReadWrite(bits: 14..<15)
        public var smpsel6: SMPSEL6

        /// Refer to for the maximum number of channels.
        @ReadWrite(bits: 15..<16)
        public var smpsel7: SMPSEL7

        /// Refer to for the maximum number of channels.
        @ReadWrite(bits: 16..<17)
        public var smpsel8: SMPSEL8

        /// Refer to for the maximum number of channels.
        @ReadWrite(bits: 17..<18)
        public var smpsel9: SMPSEL9

        /// Refer to for the maximum number of channels.
        @ReadWrite(bits: 18..<19)
        public var smpsel10: SMPSEL10

        /// Refer to for the maximum number of channels.
        @ReadWrite(bits: 19..<20)
        public var smpsel11: SMPSEL11

        /// Refer to for the maximum number of channels.
        @ReadWrite(bits: 20..<21)
        public var smpsel12: SMPSEL12

        /// Refer to for the maximum number of channels.
        @ReadWrite(bits: 21..<22)
        public var smpsel13: SMPSEL13

        /// Refer to for the maximum number of channels.
        @ReadWrite(bits: 22..<23)
        public var smpsel14: SMPSEL14

        /// Refer to for the maximum number of channels.
        @ReadWrite(bits: 23..<24)
        public var smpsel15: SMPSEL15

        /// Refer to for the maximum number of channels.
        @ReadWrite(bits: 24..<25)
        public var smpsel16: SMPSEL16

        /// Refer to for the maximum number of channels.
        @ReadWrite(bits: 25..<26)
        public var smpsel17: SMPSEL17

        /// Refer to for the maximum number of channels.
        @ReadWrite(bits: 26..<27)
        public var smpsel18: SMPSEL18

        /// Refer to for the maximum number of channels.
        @ReadWrite(bits: 27..<28)
        public var smpsel19: SMPSEL19

        /// Refer to for the maximum number of channels.
        @ReadWrite(bits: 28..<29)
        public var smpsel20: SMPSEL20

        /// Refer to for the maximum number of channels.
        @ReadWrite(bits: 29..<30)
        public var smpsel21: SMPSEL21

        /// Refer to for the maximum number of channels.
        @ReadWrite(bits: 30..<31)
        public var smpsel22: SMPSEL22
    }

    /// ADC watchdog threshold register
    @Register(bitWidth: 32)
    public struct AWD1TR {
        /// Refer to ADC_AWDxTR) on page 359.
        @ReadWrite(bits: 0..<12)
        public var lt1: LT1

        /// Refer to ADC_AWDxTR) on page 359.
        @ReadWrite(bits: 16..<28)
        public var ht1: HT1
    }

    /// ADC watchdog threshold register
    @Register(bitWidth: 32)
    public struct AWD2TR {
        /// Refer to ADC_AWDxTR) on page 359.
        @ReadWrite(bits: 0..<12)
        public var lt2: LT2

        /// Refer to ADC_AWDxTR) on page 359.
        @ReadWrite(bits: 16..<28)
        public var ht2: HT2
    }

    /// ADC channel selection register [alternate]
    @Register(bitWidth: 32)
    public struct CHSELR0 {
        /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        @ReadWrite(bits: 0..<1)
        public var chsel0: CHSEL0

        /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        @ReadWrite(bits: 1..<2)
        public var chsel1: CHSEL1

        /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        @ReadWrite(bits: 2..<3)
        public var chsel2: CHSEL2

        /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        @ReadWrite(bits: 3..<4)
        public var chsel3: CHSEL3

        /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        @ReadWrite(bits: 4..<5)
        public var chsel4: CHSEL4

        /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        @ReadWrite(bits: 5..<6)
        public var chsel5: CHSEL5

        /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        @ReadWrite(bits: 6..<7)
        public var chsel6: CHSEL6

        /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        @ReadWrite(bits: 7..<8)
        public var chsel7: CHSEL7

        /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        @ReadWrite(bits: 8..<9)
        public var chsel8: CHSEL8

        /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        @ReadWrite(bits: 9..<10)
        public var chsel9: CHSEL9

        /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        @ReadWrite(bits: 10..<11)
        public var chsel10: CHSEL10

        /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        @ReadWrite(bits: 11..<12)
        public var chsel11: CHSEL11

        /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        @ReadWrite(bits: 12..<13)
        public var chsel12: CHSEL12

        /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        @ReadWrite(bits: 13..<14)
        public var chsel13: CHSEL13

        /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        @ReadWrite(bits: 14..<15)
        public var chsel14: CHSEL14

        /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        @ReadWrite(bits: 15..<16)
        public var chsel15: CHSEL15

        /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        @ReadWrite(bits: 16..<17)
        public var chsel16: CHSEL16

        /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        @ReadWrite(bits: 17..<18)
        public var chsel17: CHSEL17

        /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        @ReadWrite(bits: 18..<19)
        public var chsel18: CHSEL18

        /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        @ReadWrite(bits: 19..<20)
        public var chsel19: CHSEL19

        /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        @ReadWrite(bits: 20..<21)
        public var chsel20: CHSEL20

        /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        @ReadWrite(bits: 21..<22)
        public var chsel21: CHSEL21

        /// If CCRDY is not yet asserted after channel configuration (writing ADC_CHSELR register or changing CHSELRMOD or SCANDIR), the value written to this bit is ignored.
        @ReadWrite(bits: 22..<23)
        public var chsel22: CHSEL22
    }

    /// ADC channel selection register [alternate]
    @Register(bitWidth: 32)
    public struct CHSELR1 {
        /// Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 0..<4)
        public var sq1: SQ1

        /// Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 4..<8)
        public var sq2: SQ2

        /// Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 8..<12)
        public var sq3: SQ3

        /// Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 12..<16)
        public var sq4: SQ4

        /// Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 16..<20)
        public var sq5: SQ5

        /// Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 20..<24)
        public var sq6: SQ6

        /// Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 24..<28)
        public var sq7: SQ7

        /// Note: The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 28..<32)
        public var sq8: SQ8
    }

    /// ADC watchdog threshold register
    @Register(bitWidth: 32)
    public struct AWD3TR {
        /// Refer to ADC_AWDxTR) on page 359.
        @ReadWrite(bits: 0..<12)
        public var lt3: LT3

        /// Refer to ADC_AWDxTR) on page 359.
        @ReadWrite(bits: 16..<28)
        public var ht3: HT3
    }

    /// ADC data register
    @Register(bitWidth: 32)
    public struct DR {
        /// Just after a calibration is complete, DATA[6:0] contains the calibration factor.
        @ReadOnly(bits: 0..<16)
        public var data: DATA
    }

    /// ADC Analog Watchdog 2 Configuration register
    @Register(bitWidth: 32)
    public struct AWD2CR {
        /// Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 0..<1)
        public var awd2ch0: AWD2CH0

        /// Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 1..<2)
        public var awd2ch1: AWD2CH1

        /// Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 2..<3)
        public var awd2ch2: AWD2CH2

        /// Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 3..<4)
        public var awd2ch3: AWD2CH3

        /// Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 4..<5)
        public var awd2ch4: AWD2CH4

        /// Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 5..<6)
        public var awd2ch5: AWD2CH5

        /// Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 6..<7)
        public var awd2ch6: AWD2CH6

        /// Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 7..<8)
        public var awd2ch7: AWD2CH7

        /// Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 8..<9)
        public var awd2ch8: AWD2CH8

        /// Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 9..<10)
        public var awd2ch9: AWD2CH9

        /// Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 10..<11)
        public var awd2ch10: AWD2CH10

        /// Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 11..<12)
        public var awd2ch11: AWD2CH11

        /// Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 12..<13)
        public var awd2ch12: AWD2CH12

        /// Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 13..<14)
        public var awd2ch13: AWD2CH13

        /// Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 14..<15)
        public var awd2ch14: AWD2CH14

        /// Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 15..<16)
        public var awd2ch15: AWD2CH15

        /// Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 16..<17)
        public var awd2ch16: AWD2CH16

        /// Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 17..<18)
        public var awd2ch17: AWD2CH17

        /// Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 18..<19)
        public var awd2ch18: AWD2CH18

        /// Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 19..<20)
        public var awd2ch19: AWD2CH19

        /// Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 20..<21)
        public var awd2ch20: AWD2CH20

        /// Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 21..<22)
        public var awd2ch21: AWD2CH21

        /// Note: The channels selected through ADC_AWD2CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 22..<23)
        public var awd2ch22: AWD2CH22
    }

    /// ADC Analog Watchdog 3 Configuration register
    @Register(bitWidth: 32)
    public struct AWD3CR {
        /// Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 0..<1)
        public var awd3ch0: AWD3CH0

        /// Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 1..<2)
        public var awd3ch1: AWD3CH1

        /// Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 2..<3)
        public var awd3ch2: AWD3CH2

        /// Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 3..<4)
        public var awd3ch3: AWD3CH3

        /// Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 4..<5)
        public var awd3ch4: AWD3CH4

        /// Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 5..<6)
        public var awd3ch5: AWD3CH5

        /// Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 6..<7)
        public var awd3ch6: AWD3CH6

        /// Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 7..<8)
        public var awd3ch7: AWD3CH7

        /// Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 8..<9)
        public var awd3ch8: AWD3CH8

        /// Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 9..<10)
        public var awd3ch9: AWD3CH9

        /// Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 10..<11)
        public var awd3ch10: AWD3CH10

        /// Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 11..<12)
        public var awd3ch11: AWD3CH11

        /// Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 12..<13)
        public var awd3ch12: AWD3CH12

        /// Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 13..<14)
        public var awd3ch13: AWD3CH13

        /// Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 14..<15)
        public var awd3ch14: AWD3CH14

        /// Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 15..<16)
        public var awd3ch15: AWD3CH15

        /// Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 16..<17)
        public var awd3ch16: AWD3CH16

        /// Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 17..<18)
        public var awd3ch17: AWD3CH17

        /// Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 18..<19)
        public var awd3ch18: AWD3CH18

        /// Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 19..<20)
        public var awd3ch19: AWD3CH19

        /// Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 20..<21)
        public var awd3ch20: AWD3CH20

        /// Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 21..<22)
        public var awd3ch21: AWD3CH21

        /// Note: The channels selected through ADC_AWD3CR must be also configured into the ADC_CHSELR registers. Refer to SQ8[3:0] for a definition of channel selection. The software is allowed to write this bit only when ADSTART=0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 22..<23)
        public var awd3ch22: AWD3CH22
    }

    /// ADC Calibration factor
    @Register(bitWidth: 32)
    public struct CALFACT {
        /// Note: Software can write these bits only when ADEN=1 (ADC is enabled and no calibration is ongoing and no conversion is ongoing). Refer to SQ8[3:0] for a definition of channel selection.
        @ReadWrite(bits: 0..<7)
        public var calfact_field: CALFACT_FIELD
    }

    /// ADC common configuration register
    @Register(bitWidth: 32)
    public struct CCR {
        /// Note: Software is allowed to write these bits only when the ADC is disabled (ADCAL = 0, ADSTART = 0, ADSTP = 0, ADDIS = 0 and ADEN = 0).
        @ReadWrite(bits: 18..<22)
        public var presc: PRESC

        /// Note: Software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 22..<23)
        public var vrefen: VREFEN

        /// Note: Software is allowed to write this bit only when ADSTART = 0 (which ensures that no conversion is ongoing).
        @ReadWrite(bits: 23..<24)
        public var tsen: TSEN
    }
}
